"""
This type stub file was generated by pyright.
"""

import platform
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, MutableMapping, NoReturn, Optional, TYPE_CHECKING, Tuple, TypeVar, Union
from _curses import _CursesWindow
from dataclasses import dataclass
from pygments.token import _TokenType
from .config import Config
from . import inspection, repl

if TYPE_CHECKING:
    ...
if platform.system() != "Windows":
    ...
F = TypeVar("F", bound=Callable[..., Any])
stdscr = ...
colors: Optional[MutableMapping[str, int]] = ...
DO_RESIZE = ...
@dataclass
class ShowListState:
    cols: int = ...
    rows: int = ...
    wl: int = ...


def forward_if_not_current(func: F) -> F:
    ...

class FakeStream:
    """Provide a fake file object which calls functions on the interface
    provided."""
    def __init__(self, interface: CLIRepl, get_dest: IO[str]) -> None:
        ...
    
    @forward_if_not_current
    def write(self, s: str) -> None:
        ...
    
    @forward_if_not_current
    def writelines(self, l: Iterable[str]) -> None:
        ...
    
    def isatty(self) -> bool:
        ...
    
    def flush(self) -> None:
        ...
    


class FakeStdin:
    """Provide a fake stdin type for things like raw_input() etc."""
    def __init__(self, interface: CLIRepl) -> None:
        """Take the curses Repl on init and assume it provides a get_key method
        which, fortunately, it does."""
        ...
    
    def __iter__(self) -> Iterator:
        ...
    
    def flush(self) -> None:
        """Flush the internal buffer. This is a no-op. Flushing stdin
        doesn't make any sense anyway."""
        ...
    
    def write(self, value: str) -> NoReturn:
        ...
    
    def isatty(self) -> bool:
        ...
    
    def readline(self, size: int = ...) -> str:
        """I can't think of any reason why anything other than readline would
        be useful in the context of an interactive interpreter so this is the
        only one I've done anything with. The others are just there in case
        someone does something weird to stop it from blowing up."""
        ...
    
    def read(self, size: Optional[int] = ...) -> str:
        ...
    
    def readlines(self, size: int = ...) -> List[str]:
        ...
    


def get_color(config: Config, name: str) -> int:
    ...

def get_colpair(config: Config, name: str) -> int:
    ...

def make_colors(config: Config) -> Dict[str, int]:
    """Init all the colours in curses and bang them into a dictionary"""
    ...

class CLIInteraction(repl.Interaction):
    def __init__(self, config: Config, statusbar: Statusbar) -> None:
        ...
    
    def confirm(self, q: str) -> bool:
        """Ask for yes or no and return boolean"""
        ...
    
    def notify(self, s: str, n: float = ..., wait_for_keypress: bool = ...) -> None:
        ...
    
    def file_prompt(self, s: str) -> Optional[str]:
        ...
    


class CLIRepl(repl.Repl):
    def __init__(self, scr: _CursesWindow, interp: repl.Interpreter, statusbar: Statusbar, config: Config, idle: Optional[Callable] = ...) -> None:
        ...
    
    def addstr(self, s: str) -> None:
        """Add a string to the current input line and figure out
        where it should go, depending on the cursor position."""
        ...
    
    def atbol(self) -> bool:
        """Return True or False accordingly if the cursor is at the beginning
        of the line (whitespace is ignored). This exists so that p_key() knows
        how to handle the tab key being pressed - if there is nothing but white
        space before the cursor then process it as a normal tab otherwise
        attempt tab completion."""
        ...
    
    def bs(self, delete_tabs: bool = ...) -> int:
        """Process a backspace"""
        ...
    
    def bs_word(self) -> str:
        ...
    
    def check(self) -> None:
        """Check if paste mode should still be active and, if not, deactivate
        it and force syntax highlighting."""
        ...
    
    def clear_current_line(self) -> None:
        """Called when a SyntaxError occurred in the interpreter. It is
        used to prevent autoindentation from occurring after a
        traceback."""
        ...
    
    def clear_wrapped_lines(self) -> None:
        """Clear the wrapped lines of the current input."""
        ...
    
    def complete(self, tab: bool = ...) -> None:
        """Get Autocomplete list and window.

        Called whenever these should be updated, and called
        with tab
        """
        ...
    
    def clrtobol(self) -> None:
        """Clear from cursor to beginning of line; usual C-u behaviour"""
        ...
    
    def cut_to_buffer(self) -> None:
        """Clear from cursor to end of line, placing into cut buffer"""
        ...
    
    def delete(self) -> None:
        """Process a del"""
        ...
    
    def echo(self, s: str, redraw: bool = ...) -> None:
        """Parse and echo a formatted string with appropriate attributes. It
        uses the formatting method as defined in formatter.py to parse the
        strings. It won't update the screen if it's reevaluating the code (as it
        does with undo)."""
        ...
    
    def end(self, refresh: bool = ...) -> bool:
        ...
    
    def hbegin(self) -> None:
        """Replace the active line with first line in history and
        increment the index to keep track"""
        ...
    
    def hend(self) -> None:
        """Same as hbegin() but, well, forward"""
        ...
    
    def back(self) -> None:
        """Replace the active line with previous line in history and
        increment the index to keep track"""
        ...
    
    def fwd(self) -> None:
        """Same as back() but, well, forward"""
        ...
    
    def search(self) -> None:
        """Search with the partial matches from the history object."""
        ...
    
    def get_key(self) -> str:
        ...
    
    def get_line(self) -> str:
        """Get a line of text and return it
        This function initialises an empty string and gets the
        curses cursor position on the screen and stores it
        for the echo() function to use later (I think).
        Then it waits for key presses and passes them to p_key(),
        which returns None if Enter is pressed (that means "Return",
        idiot)."""
        ...
    
    def home(self, refresh: bool = ...) -> bool:
        ...
    
    def lf(self) -> None:
        """Process a linefeed character; it only needs to check the
        cursor position and move appropriately so it doesn't clear
        the current line after the cursor."""
        ...
    
    def mkargspec(self, topline: inspection.FuncProps, in_arg: Union[str, int, None], down: bool) -> int:
        """This figures out what to do with the argspec and puts it nicely into
        the list window. It returns the number of lines used to display the
        argspec.  It's also kind of messy due to it having to call so many
        addstr() to get the colouring right, but it seems to be pretty
        sturdy."""
        ...
    
    def mvc(self, i: int, refresh: bool = ...) -> bool:
        """This method moves the cursor relatively from the current
        position, where:
            0 == (right) end of current line
            length of current line len(self.s) == beginning of current line
        and:
            current cursor position + i
            for positive values of i the cursor will move towards the beginning
            of the line, negative values the opposite."""
        ...
    
    def p_key(self, key: str) -> Union[None, str, bool]:
        """Process a keypress"""
        ...
    
    def print_line(self, s: Optional[str], clr: bool = ..., newline: bool = ...) -> None:
        """Chuck a line of text through the highlighter, move the cursor
        to the beginning of the line and output it to the screen."""
        ...
    
    def prompt(self, more: Any) -> None:
        """Show the appropriate Python prompt"""
        ...
    
    def push(self, s: str, insert_into_history: bool = ...) -> bool:
        ...
    
    def redraw(self) -> None:
        """Redraw the screen using screen_hist"""
        ...
    
    def repl(self) -> Tuple[Any, ...]:
        """Initialise the repl and jump into the loop. This method also has to
        keep a stack of lines entered for the horrible "undo" feature. It also
        tracks everything that would normally go to stdout in the normal Python
        interpreter so it can quickly write it to stdout on exit after
        curses.endwin(), as well as a history of lines entered for using
        up/down to go back and forth (which has to be separate to the
        evaluation history, which will be truncated when undoing."""
        ...
    
    def reprint_line(self, lineno: int, tokens: List[Tuple[_TokenType, str]]) -> None:
        """Helper function for paren highlighting: Reprint line at offset
        `lineno` in current input buffer."""
        ...
    
    def resize(self) -> None:
        """This method exists simply to keep it straight forward when
        initialising a window and resizing it."""
        ...
    
    def getstdout(self) -> str:
        """This method returns the 'spoofed' stdout buffer, for writing to a
        file or sending to a pastebin or whatever."""
        ...
    
    def reevaluate(self) -> None:
        """Clear the buffer, redraw the screen and re-evaluate the history"""
        ...
    
    def write(self, s: str) -> None:
        """For overriding stdout defaults"""
        ...
    
    def show_list(self, items: List[str], arg_pos: Union[str, int, None], topline: Optional[inspection.FuncProps] = ..., formatter: Optional[Callable] = ..., current_item: Optional[str] = ...) -> None:
        ...
    
    def size(self) -> None:
        """Set instance attributes for x and y top left corner coordinates
        and width and height for the window."""
        ...
    
    def suspend(self) -> None:
        """Suspend the current process for shell job control."""
        ...
    
    def tab(self, back: bool = ...) -> bool:
        """Process the tab key being hit.

        If there's only whitespace
        in the line or the line is blank then process a normal tab,
        otherwise attempt to autocomplete to the best match of possible
        choices in the match list.

        If `back` is True, walk backwards through the list of suggestions
        and don't indent if there are only whitespace in the line.
        """
        ...
    
    def undo(self, n: int = ...) -> None:
        ...
    
    def writetb(self, lines: List[str]) -> None:
        ...
    
    def yank_from_buffer(self) -> None:
        """Paste the text from the cut buffer at the current cursor location"""
        ...
    
    def send_current_line_to_editor(self) -> str:
        ...
    


class Statusbar:
    """This class provides the status bar at the bottom of the screen.
    It has message() and prompt() methods for user interactivity, as
    well as settext() and clear() methods for changing its appearance.

    The check() method needs to be called repeatedly if the statusbar is
    going to be aware of when it should update its display after a message()
    has been called (it'll display for a couple of seconds and then disappear).

    It should be called as:
        foo = Statusbar(stdscr, scr, 'Initial text to display')
    or, for a blank statusbar:
        foo = Statusbar(stdscr, scr)

    It can also receive the argument 'c' which will be an integer referring
    to a curses colour pair, e.g.:
        foo = Statusbar(stdscr, 'Hello', c=4)

    stdscr should be a curses window object in which to put the status bar.
    pwin should be the parent window. To be honest, this is only really here
    so the cursor can be returned to the window properly.

    """
    def __init__(self, scr: _CursesWindow, pwin: _CursesWindow, background: int, config: Config, s: Optional[str] = ..., c: Optional[int] = ...) -> None:
        """Initialise the statusbar and display the initial text (if any)"""
        ...
    
    def size(self) -> None:
        """Set instance attributes for x and y top left corner coordinates
        and width and height for the window."""
        ...
    
    def resize(self, refresh: bool = ...) -> None:
        """This method exists simply to keep it straight forward when
        initialising a window and resizing it."""
        ...
    
    def refresh(self) -> None:
        """This is here to make sure the status bar text is redraw properly
        after a resize."""
        ...
    
    def check(self) -> None:
        """This is the method that should be called every half second or so
        to see if the status bar needs updating."""
        ...
    
    def message(self, s: str, n: float = ...) -> None:
        """Display a message for a short n seconds on the statusbar and return
        it to its original state."""
        ...
    
    def prompt(self, s: str = ...) -> str:
        """Prompt the user for some input (with the optional prompt 's') and
        return the input text, then restore the statusbar to its original
        value."""
        ...
    
    def settext(self, s: str, c: Optional[int] = ..., p: bool = ...) -> None:
        """Set the text on the status bar to a new permanent value; this is the
        value that will be set after a prompt or message. c is the optional
        curses colour pair to use (if not specified the last specified colour
        pair will be used).  p is True if the cursor is expected to stay in the
        status window (e.g. when prompting)."""
        ...
    
    def clear(self) -> None:
        """Clear the status bar."""
        ...
    


def init_wins(scr: _CursesWindow, config: Config) -> Tuple[_CursesWindow, Statusbar]:
    """Initialise the two windows (the main repl interface and the little
    status bar at the bottom with some stuff in it)"""
    ...

def sigwinch(unused_scr: _CursesWindow) -> None:
    ...

def sigcont(unused_scr: _CursesWindow) -> None:
    ...

def gethw() -> Tuple[int, int]:
    """I found this code on a usenet post, and snipped out the bit I needed,
    so thanks to whoever wrote that, sorry I forgot your name, I'm sure you're
    a great guy.

    It's unfortunately necessary (unless someone has any better ideas) in order
    to allow curses and readline to work together. I looked at the code for
    libreadline and noticed this comment:

        /* This is the stuff that is hard for me.  I never seem to write good
           display routines in C.  Let's see how I do this time. */

    So I'm not going to ask any questions.

    """
    ...

def idle(caller: CLIRepl) -> None:
    """This is called once every iteration through the getkey()
    loop (currently in the Repl class, see the get_line() method).
    The statusbar check needs to go here to take care of timed
    messages and the resize handlers need to be here to make
    sure it happens conveniently."""
    ...

def do_resize(caller: CLIRepl) -> None:
    """This needs to hack around readline and curses not playing
    nicely together. See also gethw() above."""
    ...

class FakeDict:
    """Very simple dict-alike that returns a constant value for any key -
    used as a hacky solution to using a colours dict containing colour codes if
    colour initialisation fails."""
    def __init__(self, val: int) -> None:
        ...
    
    def __getitem__(self, k: Any) -> int:
        ...
    


def newwin(background: int, *args: int) -> _CursesWindow:
    """Wrapper for curses.newwin to automatically set background colour on any
    newly created window."""
    ...

def curses_wrapper(func: Callable, *args: Any, **kwargs: Any) -> Any:
    """Like curses.wrapper(), but reuses stdscr when called again."""
    ...

def main_curses(scr: _CursesWindow, args: List[str], config: Config, interactive: bool = ..., locals_: Optional[Dict[str, Any]] = ..., banner: Optional[str] = ...) -> Tuple[Tuple[Any, ...], str]:
    """main function for the curses convenience wrapper

    Initialise the two main objects: the interpreter
    and the repl. The repl does what a repl does and lots
    of other cool stuff like syntax highlighting and stuff.
    I've tried to keep it well factored but it needs some
    tidying up, especially in separating the curses stuff
    from the rest of the repl.

    Returns a tuple (exit value, output), where exit value is a tuple
    with arguments passed to SystemExit.
    """
    ...

def main(args: Optional[List[str]] = ..., locals_: Optional[MutableMapping[str, str]] = ..., banner: Optional[str] = ...) -> Any:
    ...

if __name__ == "__main__":
    ...
