"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, Optional

"""simple evaluation of side-effect free code

In order to provide fancy completion, some code can be executed safely.
"""
_is_py38 = ...
_is_py39 = ...
_string_type_nodes = ...
_numeric_types = ...
_name_type_nodes = ...
class EvaluationError(Exception):
    """Raised if an exception occurred in safe_eval."""
    ...


def safe_eval(expr: str, namespace: Dict[str, Any]) -> Any:
    """Not all that safe, just catches some errors"""
    ...

def simple_eval(node_or_string, namespace=...): # -> Any | str | bytes | int | float | complex | tuple[Any, ...] | list[Any] | dict[Any, Any] | set[Any]:
    """
    Safely evaluate an expression node or a string containing a Python
    expression without triggering any user code.

    The string or node provided may only consist of:
    * the following Python literal structures: strings, numbers, tuples,
        lists, dicts, and sets
    * variable names causing lookups in the passed in namespace or builtins
    * getitem calls using the [] syntax on objects of the types above

    Like Python 3's literal_eval, unary and binary + and - operations are
    allowed on all builtin numeric types.

    The optional namespace dict-like ought not to cause side effects on lookup.
    """
    ...

def safe_getitem(obj, index):
    """Safely tries to access obj[index]"""
    ...

def find_attribute_with_name(node, name): # -> Attribute | None:
    ...

def evaluate_current_expression(cursor_offset: int, line: str, namespace: Optional[Dict[str, Any]] = ...) -> Any:
    """
    Return evaluated expression to the right of the dot of current attribute.

    Only evaluates builtin objects, and do any attribute lookup.
    """
    ...

def evaluate_current_attribute(cursor_offset, line, namespace=...): # -> Any:
    """Safely evaluates the expression having an attributed accessed"""
    ...

