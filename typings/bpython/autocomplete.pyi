"""
This type stub file was generated by pyright.
"""

import abc
from enum import Enum
from typing import Any, Dict, Iterator, List, Optional, Sequence, Set, Tuple
from . import inspection
from .line import LinePart
from .importcompletion import ModuleGatherer

logger = ...
class AutocompleteModes(Enum):
    NONE = ...
    SIMPLE = ...
    SUBSTRING = ...
    FUZZY = ...
    @classmethod
    def from_string(cls, value: str) -> Optional[AutocompleteModes]:
        ...
    


MAGIC_METHODS = ...
KEYWORDS = ...
_MODES_MAP = ...
class BaseCompletionType:
    """Describes different completion types"""
    def __init__(self, shown_before_tab: bool = ..., mode: AutocompleteModes = ...) -> None:
        ...
    
    @abc.abstractmethod
    def matches(self, cursor_offset: int, line: str, **kwargs: Any) -> Optional[Set[str]]:
        """Returns a list of possible matches given a line and cursor, or None
        if this completion type isn't applicable.

        ie, import completion doesn't make sense if there cursor isn't after
        an import or from statement, so it ought to return None.

        Completion types are used to:
            * `locate(cur, line)` their initial target word to replace given a
              line and cursor
            * find `matches(cur, line)` that might replace that word
            * `format(match)` matches to be displayed to the user
            * determine whether suggestions should be `shown_before_tab`
            * `substitute(cur, line, match)` in a match for what's found with
              `target`
        """
        ...
    
    @abc.abstractmethod
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        """Returns a Linepart namedtuple instance or None given cursor and line

        A Linepart namedtuple contains a start, stop, and word. None is
        returned if no target for this type of completion is found under
        the cursor."""
        ...
    
    def format(self, word: str) -> str:
        ...
    
    def substitute(self, cursor_offset: int, line: str, match: str) -> Tuple[int, str]:
        """Returns a cursor offset and line with match swapped in"""
        ...
    
    @property
    def shown_before_tab(self) -> bool:
        """Whether suggestions should be shown before the user hits tab, or only
        once that has happened."""
        ...
    


class CumulativeCompleter(BaseCompletionType):
    """Returns combined matches from several completers"""
    def __init__(self, completers: Sequence[BaseCompletionType], mode: AutocompleteModes = ...) -> None:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    
    def format(self, word: str) -> str:
        ...
    
    def matches(self, cursor_offset: int, line: str, **kwargs: Any) -> Optional[Set[str]]:
        ...
    


class ImportCompletion(BaseCompletionType):
    def __init__(self, module_gatherer: ModuleGatherer, mode: AutocompleteModes = ...) -> None:
        ...
    
    def matches(self, cursor_offset: int, line: str, **kwargs: Any) -> Optional[Set[str]]:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    
    def format(self, word: str) -> str:
        ...
    


class FilenameCompletion(BaseCompletionType):
    def __init__(self, mode: AutocompleteModes = ...) -> None:
        ...
    
    def matches(self, cursor_offset: int, line: str, **kwargs: Any) -> Optional[Set[str]]:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    
    def format(self, filename: str) -> str:
        ...
    


class AttrCompletion(BaseCompletionType):
    attr_matches_re = ...
    def matches(self, cursor_offset: int, line: str, *, locals_: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> Optional[Set[str]]:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    
    def format(self, word: str) -> str:
        ...
    
    def attr_matches(self, text: str, namespace: Dict[str, Any]) -> Iterator[str]:
        """Taken from rlcompleter.py and bent to my will."""
        ...
    
    def attr_lookup(self, obj: Any, expr: str, attr: str) -> Iterator[str]:
        """Second half of attr_matches."""
        ...
    
    def list_attributes(self, obj: Any) -> List[str]:
        ...
    


class DictKeyCompletion(BaseCompletionType):
    def matches(self, cursor_offset: int, line: str, *, locals_: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> Optional[Set[str]]:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    
    def format(self, match: str) -> str:
        ...
    


class MagicMethodCompletion(BaseCompletionType):
    def matches(self, cursor_offset: int, line: str, *, current_block: Optional[str] = ..., complete_magic_methods: Optional[bool] = ..., **kwargs: Any) -> Optional[Set[str]]:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    


class GlobalCompletion(BaseCompletionType):
    def matches(self, cursor_offset: int, line: str, *, locals_: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> Optional[Set[str]]:
        """Compute matches when text is a simple name.
        Return a list of all keywords, built-in functions and names currently
        defined in self.namespace that match.
        """
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    


class ParameterNameCompletion(BaseCompletionType):
    def matches(self, cursor_offset: int, line: str, *, funcprops: Optional[inspection.FuncProps] = ..., **kwargs: Any) -> Optional[Set[str]]:
        ...
    
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    


class ExpressionAttributeCompletion(AttrCompletion):
    def locate(self, cursor_offset: int, line: str) -> Optional[LinePart]:
        ...
    
    def matches(self, cursor_offset: int, line: str, *, locals_: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> Optional[Set[str]]:
        ...
    


def get_completer(completers: Sequence[BaseCompletionType], cursor_offset: int, line: str, *, locals_: Optional[Dict[str, Any]] = ..., argspec: Optional[inspection.FuncProps] = ..., history: Optional[List[str]] = ..., current_block: Optional[str] = ..., complete_magic_methods: Optional[bool] = ...) -> Tuple[List[str], Optional[BaseCompletionType]]:
    """Returns a list of matches and an applicable completer

    If no matches available, returns a tuple of an empty list and None

    cursor_offset is the current cursor column
    line is a string of the current line
    kwargs (all optional):
        locals_ is a dictionary of the environment
        argspec is an inspection.FuncProps instance for the current function where
            the cursor is
        current_block is the possibly multiline not-yet-evaluated block of
            code which the current line is part of
        complete_magic_methods is a bool of whether we ought to complete
            double underscore methods like __len__ in method signatures
    """
    ...

def get_default_completer(mode: AutocompleteModes, module_gatherer: ModuleGatherer) -> Tuple[BaseCompletionType, ...]:
    ...

