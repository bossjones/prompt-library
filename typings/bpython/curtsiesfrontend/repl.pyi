"""
This type stub file was generated by pyright.
"""

import contextlib
from enum import Enum
from types import FrameType, TracebackType
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple, Type, Union
from .._typing_compat import Literal
from curtsies import FSArray, events
from curtsies.window import CursorAwareWindow
from ..config import Config
from .coderunner import CodeRunner
from .interpreter import Interp
from .manual_readline import AbstractEdits
from ..repl import Repl

logger = ...
INCONSISTENT_HISTORY_MSG = ...
CONTIGUITY_BROKEN_MSG = ...
EXAMPLE_CONFIG_URL = ...
EDIT_SESSION_HEADER = ...
MAX_EVENTS_POSSIBLY_NOT_PASTE = ...
class SearchMode(Enum):
    NO_SEARCH = ...
    INCREMENTAL_SEARCH = ...
    REVERSE_INCREMENTAL_SEARCH = ...


class LineType(Enum):
    """Used when adding a tuple to all_logical_lines, to get input / output values
    having to actually type/know the strings"""
    INPUT = ...
    OUTPUT = ...


class FakeStdin:
    """The stdin object user code will reference

    In user code, sys.stdin.read() asks the user for interactive input,
    so this class returns control to the UI to get that input."""
    def __init__(self, coderunner: CodeRunner, repl: BaseRepl, configured_edit_keys: Optional[AbstractEdits] = ...) -> None:
        ...
    
    def process_event(self, e: Union[events.Event, str]) -> None:
        ...
    
    def add_input_character(self, e: str) -> None:
        ...
    
    def readline(self, size: int = ...) -> str:
        ...
    
    def readlines(self, size: Optional[int] = ...) -> List[str]:
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def isatty(self) -> bool:
        ...
    
    def flush(self) -> None:
        """Flush the internal buffer. This is a no-op. Flushing stdin
        doesn't make any sense anyway."""
        ...
    
    def write(self, value):
        ...
    
    def close(self) -> None:
        ...
    
    @property
    def encoding(self) -> str:
        ...
    


class ReevaluateFakeStdin:
    """Stdin mock used during reevaluation (undo) so raw_inputs don't have to
    be reentered"""
    def __init__(self, fakestdin: FakeStdin, repl: BaseRepl) -> None:
        ...
    
    def readline(self): # -> str:
        ...
    


class ImportLoader:
    """Wrapper for module loaders to watch their paths with watchdog."""
    def __init__(self, watcher, loader) -> None:
        ...
    
    def __getattr__(self, name): # -> Callable[..., Any] | Any:
        ...
    


class ImportFinder:
    """Wrapper for finders in sys.meta_path to wrap all loaders with ImportLoader."""
    def __init__(self, watcher, finder) -> None:
        ...
    
    def __getattr__(self, name): # -> Callable[..., Any] | Any:
        ...
    


class BaseRepl(Repl):
    """Python Repl

    Reacts to events like
     - terminal dimensions and change events
     - keystrokes
    Behavior altered by
     - number of scroll downs that were necessary to render array after each
       display
     - initial cursor position
    outputs:
     - 2D array to be rendered

    BaseRepl is mostly view-independent state of Repl - but self.width and
    self.height are important for figuring out how to wrap lines for example.
    Usually self.width and self.height should be set by receiving a window
    resize event, not manually set to anything - as long as the first event
    received is a window resize event, this works fine.

    Subclasses are responsible for implementing several methods.
    """
    def __init__(self, config: Config, window: CursorAwareWindow, locals_: Optional[Dict[str, Any]] = ..., banner: Optional[str] = ..., interp: Optional[Interp] = ..., orig_tcattrs: Optional[List[Any]] = ...) -> None:
        """
        locals_ is a mapping of locals to pass into the interpreter
        config is a bpython config.Struct with config attributes
        banner is a string to display briefly in the status bar
        interp is an interpreter instance to use
        original terminal state, useful for shelling out with normal terminal
        """
        ...
    
    def get_cursor_vertical_diff(self): # -> Literal[0]:
        """Return how the cursor moved due to a window size change"""
        ...
    
    def get_top_usable_line(self): # -> Literal[0]:
        """Return the top line of display that can be rewritten"""
        ...
    
    def get_term_hw(self): # -> tuple[Literal[50], Literal[10]]:
        """Returns the current width and height of the display area."""
        ...
    
    def request_undo(self, n=...):
        """Like request_refresh, but for undo request events."""
        ...
    
    def on_suspend(self):
        """Will be called on sigtstp.

        Do whatever cleanup would allow the user to use other programs."""
        ...
    
    def after_suspend(self):
        """Will be called when process foregrounded after suspend.

        See to it that process_event is called with None to trigger a refresh
        if not in the middle of a process_event call when suspend happened."""
        ...
    
    def request_refresh(self): # -> None:
        """Request that the bpython display to be refreshed soon."""
        ...
    
    def request_reload(self, files_modified: Sequence[str] = ...) -> None:
        """Request that a ReloadEvent be passed next into process_event"""
        ...
    
    def schedule_refresh(self, when: float = ...) -> None:
        """Schedule a ScheduledRefreshRequestEvent for when.

        Such a event should interrupt if blocked waiting for keyboard input"""
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]) -> Literal[False]:
        ...
    
    def sigwinch_handler(self, signum: int, frame: Optional[FrameType]) -> None:
        ...
    
    def sigtstp_handler(self, signum: int, frame: Optional[FrameType]) -> None:
        ...
    
    def clean_up_current_line_for_exit(self): # -> None:
        """Called when trying to exit to prep for final paint"""
        ...
    
    def process_event(self, e: Union[events.Event, str]) -> Optional[bool]:
        """Returns True if shutting down, otherwise returns None.
        Mostly mutates state of Repl object"""
        ...
    
    def process_control_event(self, e: events.Event) -> Optional[bool]:
        ...
    
    def process_key_event(self, e: str) -> None:
        ...
    
    def is_closing_quote(self, e: str) -> bool:
        ...
    
    def insert_char_pair_start(self, e): # -> None:
        """Accepts character which is a part of CHARACTER_PAIR_MAP
        like brackets and quotes, and appends it to the line with
        an appropriate character pair ending. Closing character can only be inserted
        when the next character is either a closing character or a space

        e.x. if you type "(" (lparen) , this will insert "()"
        into the line
        """
        ...
    
    def insert_char_pair_end(self, e): # -> None:
        """Accepts character which is a part of CHARACTER_PAIR_MAP
        like brackets and quotes, and checks whether it should be
        inserted to the line or overwritten

        e.x. if you type ")" (rparen) , and your cursor is directly
        above another ")" (rparen) in the cmd, this will just skip
        it and move the cursor.
        If there is no same character underneath the cursor, the
        character will be printed/appended to the line
        """
        ...
    
    def get_last_word(self): # -> None:
        ...
    
    def incremental_search(self, reverse=..., include_current=...): # -> None:
        ...
    
    def readline_kill(self, e): # -> None:
        ...
    
    def on_enter(self, new_code=..., reset_rl_history=...): # -> None:
        ...
    
    def on_tab(self, back=...): # -> None:
        """Do something on tab key
        taken from bpython.cli

        Does one of the following:
        1) add space to move up to the next %4==0 column
        2) complete the current word with characters common to all completions
        3) select the first or last match
        4) select the next or previous match if already have a match
        """
        ...
    
    def is_completion_callable(self, completion): # -> bool:
        """Checks whether given completion is callable (e.x. function)"""
        ...
    
    def append_closing_character(self, completion): # -> str:
        """Appends closing character/bracket to the completion"""
        ...
    
    def on_control_d(self): # -> None:
        ...
    
    def cut_to_buffer(self): # -> None:
        ...
    
    def yank_from_buffer(self): # -> None:
        ...
    
    def operate_and_get_next(self): # -> None:
        ...
    
    def up_one_line(self): # -> None:
        ...
    
    def down_one_line(self): # -> None:
        ...
    
    def process_simple_keypress(self, e: str): # -> None:
        ...
    
    def send_current_block_to_external_editor(self, filename=...): # -> None:
        """
        Sends the current code block to external editor to be edited. Usually bound to C-x.
        """
        ...
    
    def send_session_to_external_editor(self, filename=...): # -> None:
        """
        Sends entire bpython session to external editor to be edited. Usually bound to F7.
        """
        ...
    
    def clear_modules_and_reevaluate(self): # -> None:
        ...
    
    def toggle_file_watch(self): # -> None:
        ...
    
    def add_normal_character(self, char, narrow_search=...): # -> None:
        ...
    
    def add_to_incremental_search(self, char=..., backspace=...): # -> None:
        """Modify the current search term while in incremental search.

        The only operations allowed in incremental search mode are
        adding characters and backspacing."""
        ...
    
    def update_completion(self, tab=...): # -> None:
        """Update visible docstring and matches and box visibility"""
        ...
    
    def predicted_indent(self, line): # -> int:
        ...
    
    def push(self, line, insert_into_history=...): # -> None:
        """Push a line of code onto the buffer, start running the buffer

        If the interpreter successfully runs the code, clear the buffer
        """
        ...
    
    def run_code_and_maybe_finish(self, for_code=...): # -> None:
        ...
    
    def keyboard_interrupt(self): # -> None:
        ...
    
    def unhighlight_paren(self): # -> None:
        """Modify line in self.display_buffer to unhighlight a paren if
        possible.

        self.highlighted_paren should be a line in ?
        """
        ...
    
    def clear_current_block(self, remove_from_history=...): # -> None:
        ...
    
    def get_current_block(self): # -> str:
        """
        Returns the current code block as string (without prompts)
        """
        ...
    
    def send_to_stdouterr(self, output): # -> None:
        """Send unicode strings or FmtStr to Repl stdout or stderr

        Must be able to handle FmtStrs because interpreter pass in
        tracebacks already formatted."""
        ...
    
    def send_to_stdin(self, line): # -> None:
        ...
    
    @property
    def done(self): # -> bool:
        """Whether the last block is complete - which prompt to use, ps1 or
        ps2"""
        ...
    
    @property
    def current_line_formatted(self): # -> FmtStr:
        """The colored current line (no prompt, not wrapped)"""
        ...
    
    @property
    def lines_for_display(self): # -> list[FmtStr]:
        """All display lines (wrapped, colored, with prompts)"""
        ...
    
    @property
    def display_buffer_lines(self): # -> list[Any]:
        """The display lines (wrapped, colored, +prompts) of current buffer"""
        ...
    
    @property
    def display_line_with_prompt(self): # -> FmtStr:
        """colored line with prompt"""
        ...
    
    @property
    def current_cursor_line_without_suggestion(self): # -> FmtStr | str:
        """
        Current line, either output/input or Python prompt + code

        :returns: FmtStr
        """
        ...
    
    @property
    def current_cursor_line(self): # -> FmtStr | str:
        ...
    
    @property
    def current_suggestion(self): # -> str:
        ...
    
    @property
    def current_output_line(self): # -> str | FmtStr:
        """line of output currently being written, and stdin typed"""
        ...
    
    @current_output_line.setter
    def current_output_line(self, value): # -> None:
        ...
    
    def number_of_padding_chars_on_current_cursor_line(self): # -> int:
        """To avoid cutting off two-column characters at the end of lines where
        there's only one column left, curtsies adds a padding char (u' ').
        It's important to know about these for cursor positioning.

        Should return zero unless there are fullwidth characters."""
        ...
    
    def paint(self, about_to_exit=..., user_quit=..., try_preserve_history_height=..., min_infobox_height=...) -> Tuple[FSArray, Tuple[int, int]]:
        """Returns an array of min_height or more rows and width columns, plus
        cursor position

        Paints the entire screen - ideally the terminal display layer will take
        a diff and only write to the screen in portions that have changed, but
        the idea is that we don't need to worry about that here, instead every
        frame is completely redrawn because less state is cool!

        try_preserve_history_height is the the number of rows of content that
        must be visible before the suggestion box scrolls the terminal in order
        to display more than min_infobox_height rows of suggestions, docs etc.
        """
        ...
    
    @contextlib.contextmanager
    def in_paste_mode(self): # -> Generator[None, Any, None]:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def echo(self, msg, redraw=...): # -> None:
        """
        Notification that redrawing the current line is necessary (we don't
        care, since we always redraw the whole screen)

        Supposed to parse and echo a formatted string with appropriate
        attributes. It's not supposed to update the screen if it's reevaluating
        the code (as it does with undo)."""
        ...
    
    @property
    def cpos(self): # -> int:
        "many WATs were had - it's the pos from the end of the line back"
        ...
    
    def reprint_line(self, lineno, tokens): # -> None:
        ...
    
    def take_back_buffer_line(self): # -> None:
        ...
    
    def take_back_empty_line(self): # -> None:
        ...
    
    def prompt_undo(self): # -> None:
        ...
    
    def redo(self) -> None:
        ...
    
    def reevaluate(self, new_code=...): # -> None:
        """bpython.Repl.undo calls this"""
        ...
    
    def initialize_interp(self) -> None:
        ...
    
    def getstdout(self) -> str:
        """
        Returns a string of the current bpython session, wrapped, WITH prompts.
        """
        ...
    
    def focus_on_subprocess(self, args): # -> None:
        ...
    
    def pager(self, text: str) -> None:
        """Runs an external pager on text

        text must be a str"""
        ...
    
    def show_source(self) -> None:
        ...
    
    def help_text(self) -> str:
        ...
    
    def version_help_text(self) -> str:
        ...
    
    def key_help_text(self) -> str:
        ...
    
    def get_session_formatted_for_file(self) -> str:
        ...
    
    @property
    def ps1(self): # -> str:
        ...
    
    @property
    def ps2(self): # -> str:
        ...
    


def is_nop(char: str) -> bool:
    ...

def tabs_to_spaces(line: str) -> str:
    ...

def compress_paste_event(paste_event): # -> None:
    """If all events in a paste event are identical and not simple characters,
    returns one of them

    Useful for when the UI is running so slowly that repeated keypresses end up
    in a paste event.  If we value not getting delayed and assume the user is
    holding down a key to produce such frequent key events, it makes sense to
    drop some of the events.
    """
    ...

def just_simple_events(event_list: Iterable[Union[str, events.Event]]) -> List[str]:
    ...

def is_simple_event(e: Union[str, events.Event]) -> bool:
    ...

