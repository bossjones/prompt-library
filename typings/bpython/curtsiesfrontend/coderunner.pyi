"""
This type stub file was generated by pyright.
"""

"""For running Python code that could interrupt itself at any time in order to,
for example, ask for a read on stdin, or a write on stdout

The CodeRunner spawns a greenlet to run code in, and that code can suspend its
own execution to ask the main greenlet to refresh the display or get
information.

Greenlets are basically threads that can explicitly switch control to each
other.  You can replace the word "greenlet" with "thread" in these docs if that
makes more sense to you.
"""
logger = ...
class SigintHappened:
    """If this class is returned, a SIGINT happened while the main greenlet"""
    ...


class SystemExitFromCodeRunner(SystemExit):
    """If this class is returned, a SystemExit happened while in the code
    greenlet"""
    ...


class RequestFromCodeRunner:
    """Message from the code runner"""
    ...


class Wait(RequestFromCodeRunner):
    """Running code would like the main loop to run for a bit"""
    ...


class Refresh(RequestFromCodeRunner):
    """Running code would like the main loop to refresh the display"""
    ...


class Done(RequestFromCodeRunner):
    """Running code is done running"""
    ...


class Unfinished(RequestFromCodeRunner):
    """Source code wasn't executed because it wasn't fully formed"""
    ...


class SystemExitRequest(RequestFromCodeRunner):
    """Running code raised a SystemExit"""
    def __init__(self, args) -> None:
        ...
    


class CodeRunner:
    """Runs user code in an interpreter.

    Running code requests a refresh by calling
    request_from_main_context(force_refresh=True), which
    suspends execution of the code and switches back to the main greenlet

    After load_code() is called with the source code to be run,
    the run_code() method should be called to start running the code.
    The running code may request screen refreshes and user input
    by calling request_from_main_context.
    When this are called, the running source code cedes
    control, and the current run_code() method call returns.

    The return value of run_code() determines whether the method ought
    to be called again to complete execution of the source code.

    Once the screen refresh has occurred or the requested user input
    has been gathered, run_code() should be called again, passing in any
    requested user input. This continues until run_code returns Done.

    The code greenlet is responsible for telling the main greenlet
    what it wants returned in the next run_code call - CodeRunner
    just passes whatever is passed in to run_code(for_code) to the
    code greenlet
    """
    def __init__(self, interp=..., request_refresh=...) -> None:
        """
        interp is an interpreter object to use. By default a new one is
        created.

        request_refresh is a function that will be called each time the running
        code asks for a refresh - to, for example, update the screen.
        """
        ...
    
    @property
    def running(self): # -> greenlet | None:
        """Returns greenlet if code has been loaded greenlet has been
        started"""
        ...
    
    def load_code(self, source): # -> None:
        """Prep code to be run"""
        ...
    
    def run_code(self, for_code=...): # -> Done | Unfinished | Literal[False] | None:
        """Returns Truthy values if code finishes, False otherwise

        if for_code is provided, send that value to the code greenlet
        if source code is complete, returns "done"
        if source code is incomplete, returns "unfinished"
        """
        ...
    
    def sigint_handler(self, *args): # -> None:
        """SIGINT handler to use while code is running or request being
        fulfilled"""
        ...
    
    def request_from_main_context(self, force_refresh=...): # -> Any:
        """Return the argument passed in to .run_code(for_code)

        Nothing means calls to run_code must be... ???
        """
        ...
    


class FakeOutput:
    def __init__(self, coderunner, on_write, real_fileobj) -> None:
        """Fakes sys.stdout or sys.stderr

        on_write should always take unicode

        fileno should be the fileno that on_write will
                output to (e.g. 1 for standard output).
        """
        ...
    
    def write(self, s, *args, **kwargs):
        ...
    
    def fileno(self):
        ...
    
    def writelines(self, l): # -> None:
        ...
    
    def flush(self): # -> None:
        ...
    
    def isatty(self): # -> Literal[True]:
        ...
    
    @property
    def encoding(self):
        ...
    


