"""
This type stub file was generated by pyright.
"""

import urwid
from typing import Optional
from . import repl

"""bpython backend based on Urwid.

Based on Urwid 0.9.9.

This steals many things from bpython's "cli" backend.

This is still *VERY* rough.
"""
COLORMAP = ...
if urwid.VERSION < (1, 0, 0) and hasattr(urwid, "TwistedEventLoop"):
    class TwistedEventLoop(urwid.TwistedEventLoop):
        """TwistedEventLoop modified to properly stop the reactor.

        urwid 0.9.9 and 0.9.9.1 crash the reactor on ExitMainLoop instead
        of stopping it. One obvious way this breaks is if anything used
        the reactor's thread pool: that thread pool is not shut down if
        the reactor is not stopped, which means python hangs on exit
        (joining the non-daemon threadpool threads that never exit). And
        the default resolver is the ThreadedResolver, so if we looked up
        any names we hang on exit. That is bad enough that we hack up
        urwid a bit here to exit properly.
        """
        def handle_exit(self, f): # -> Callable[..., Any | None]:
            ...
        
    
    
else:
    TwistedEventLoop = ...
class StatusbarEdit(urwid.Edit):
    """Wrapper around urwid.Edit used for the prompt in Statusbar.

    This class only adds a single signal that is emitted if the user presses
    Enter."""
    signals = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def keypress(self, size, key): # -> None:
        ...
    


class Statusbar:
    """Statusbar object, ripped off from bpython.cli.

    This class provides the status bar at the bottom of the screen.
    It has message() and prompt() methods for user interactivity, as
    well as settext() and clear() methods for changing its appearance.

    The check() method needs to be called repeatedly if the statusbar is
    going to be aware of when it should update its display after a message()
    has been called (it'll display for a couple of seconds and then disappear).

    It should be called as:
        foo = Statusbar('Initial text to display')
    or, for a blank statusbar:
        foo = Statusbar()

    The "widget" attribute is an urwid widget.
    """
    signals = ...
    def __init__(self, config, s=..., main_loop=...) -> None:
        ...
    
    def message(self, s, n=...): # -> None:
        """Display a message for a short n seconds on the statusbar and return
        it to its original state."""
        ...
    
    def prompt(self, s=..., single=...): # -> None:
        """Prompt the user for some input (with the optional prompt 's'). After
        the user hit enter the signal 'prompt_result' will be emitted and the
        status bar will be reset. If single is True, the first keypress will be
        returned."""
        ...
    
    def settext(self, s, permanent=...): # -> None:
        """Set the text on the status bar to a new value. If permanent is True,
        the new value will be permanent. If that status bar is in prompt mode,
        the prompt will be aborted."""
        ...
    
    def clear(self): # -> None:
        """Clear the status bar."""
        ...
    


def decoding_input_filter(keys, raw): # -> list[Any]:
    """Input filter for urwid which decodes each key with the locale's
    preferred encoding.'"""
    ...

def format_tokens(tokensource): # -> Generator[tuple[str, Any], Any, None]:
    ...

class BPythonEdit(urwid.Edit):
    """Customized editor *very* tightly interwoven with URWIDRepl.

    Changes include:

    - The edit text supports markup, not just the caption.
      This works by calling set_edit_markup from the change event
      as well as whenever markup changes while text does not.

    - The widget can be made readonly, which currently just means
      it is no longer selectable and stops drawing the cursor.

      This is currently a one-way operation, but that is just because
      I only need and test the readwrite->readonly transition.

    - move_cursor_to_coords is ignored
      (except for internal calls from keypress or mouse_event).

    - arrow up/down are ignored.

    - an "edit-pos-changed" signal is emitted when edit_pos changes.
    """
    signals = ...
    def __init__(self, config, *args, **kwargs) -> None:
        ...
    
    def set_edit_pos(self, pos): # -> None:
        ...
    
    def get_edit_pos(self):
        ...
    
    edit_pos = ...
    def make_readonly(self): # -> None:
        ...
    
    def set_edit_markup(self, markup): # -> None:
        """Call this when markup changes but the underlying text does not.

        You should arrange for this to be called from the 'change' signal.
        """
        ...
    
    def get_text(self): # -> tuple[Any, Any]:
        ...
    
    def selectable(self): # -> bool:
        ...
    
    def get_cursor_coords(self, *args, **kwargs): # -> None:
        ...
    
    def render(self, size, focus=...):
        ...
    
    def get_pref_col(self, size): # -> Literal['left']:
        ...
    
    def move_cursor_to_coords(self, *args): # -> Literal[False]:
        ...
    
    def keypress(self, size, key): # -> None:
        ...
    
    def mouse_event(self, *args):
        ...
    


class BPythonListBox(urwid.ListBox):
    """Like `urwid.ListBox`, except that it does not eat up and
    down keys.
    """
    def keypress(self, size, key): # -> Literal['up', 'down']:
        ...
    


class Tooltip(urwid.BoxWidget):
    """Container inspired by Overlay to position our tooltip.

    bottom_w should be a BoxWidget.
    The top window currently has to be a listbox to support shrinkwrapping.

    This passes keyboard events to the bottom instead of the top window.

    It also positions the top window relative to the cursor position
    from the bottom window and hides it if there is no cursor.
    """
    def __init__(self, bottom_w, listbox) -> None:
        ...
    
    def selectable(self):
        ...
    
    def keypress(self, size, key):
        ...
    
    def mouse_event(self, size, event, button, col, row, focus): # -> Literal[False]:
        ...
    
    def get_cursor_coords(self, size):
        ...
    
    def render(self, size, focus=...):
        ...
    


class URWIDInteraction(repl.Interaction):
    def __init__(self, config, statusbar, frame) -> None:
        ...
    
    def confirm(self, q, callback): # -> None:
        """Ask for yes or no and call callback to return the result"""
        ...
    
    def notify(self, s, n=..., wait_for_keypress=...):
        ...
    
    def prompt(self, s, callback=..., single=...): # -> None:
        """Prompt the user for input. The result will be returned via calling
        callback. Note that there can only be one prompt active. But the
        callback can already start a new prompt."""
        ...
    
    def file_prompt(self, s: str) -> Optional[str]:
        ...
    


class URWIDRepl(repl.Repl):
    _time_between_redraws = ...
    def __init__(self, event_loop, palette, interpreter, config) -> None:
        ...
    
    def echo(self, orig_s): # -> None:
        ...
    
    current_line = ...
    def cw(self): # -> None:
        """Return the current word (incomplete word left of cursor)."""
        ...
    
    @property
    def cpos(self): # -> Any | int:
        ...
    
    cursor_offset = ...
    def reprint_line(self, lineno, tokens): # -> None:
        ...
    
    def getstdout(self): # -> str:
        """This method returns the 'spoofed' stdout buffer, for writing to a
        file or sending to a pastebin or whatever."""
        ...
    
    def ask_confirmation(self, q): # -> bool:
        """Ask for yes or no and return boolean"""
        ...
    
    def reevaluate(self): # -> None:
        """Clear the buffer, redraw the screen and re-evaluate the history"""
        ...
    
    def write(self, s): # -> None:
        """For overriding stdout defaults"""
        ...
    
    def push(self, s, insert_into_history=...): # -> bool | None:
        ...
    
    def start(self): # -> None:
        ...
    
    def keyboard_interrupt(self): # -> None:
        ...
    
    def prompt(self, more): # -> None:
        ...
    
    def on_input_change(self, edit, text): # -> None:
        ...
    
    def on_edit_pos_changed(self, edit, position): # -> None:
        """Gets called when the cursor position inside the edit changed.
        Rehighlight the current line because there might be a paren under
        the cursor now."""
        ...
    
    def handle_input(self, event): # -> None:
        ...
    
    def tab(self, back=...): # -> Literal[True]:
        """Process the tab key being hit.

        If the line is blank or has only whitespace: indent.

        If there is text before the cursor: cycle completions.

        If `back` is True cycle backwards through completions, and return
        instead of indenting.

        Returns True if the key was handled.
        """
        ...
    


def main(args=..., locals_=..., banner=...): # -> Any | None:
    ...

def load_urwid_command_map(config): # -> None:
    ...

if __name__ == "__main__":
    ...
