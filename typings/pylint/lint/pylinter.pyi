"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable, Sequence
from typing import Any, Protocol
from astroid import nodes
from pylint import checkers, interfaces, reporters
from pylint.checkers.base_checker import BaseChecker
from pylint.config.arguments_manager import _ArgumentsManager
from pylint.lint.message_state_handler import _MessageStateHandler
from pylint.reporters.base_reporter import BaseReporter
from pylint.typing import FileItem, MessageDefinitionTuple, Options
from pylint.utils import ASTWalker

"""
This type stub file was generated by pyright.
"""
MANAGER = ...
class GetAstProtocol(Protocol):
    def __call__(self, filepath: str, modname: str, data: str | None = ...) -> nodes.Module:
        ...



MSGS: dict[str, MessageDefinitionTuple] = ...
class PyLinter(_ArgumentsManager, _MessageStateHandler, reporters.ReportsHandlerMixIn, checkers.BaseChecker):
    """Lint Python modules using external checkers.

    This is the main checker controlling the other ones and the reports
    generation. It is itself both a raw checker and an astroid checker in order
    to:
    * handle message activation / deactivation at the module level
    * handle some basic but necessary stats' data (number of classes, methods...)

    IDE plugin developers: you may have to call
    `astroid.MANAGER.clear_cache()` across runs if you want
    to ensure the latest code version is actually checked.

    This class needs to support pickling for parallel linting to work. The exception
    is reporter member; see check_parallel function for more details.
    """
    name = ...
    msgs = ...
    crash_file_path: str = ...
    option_groups_descs = ...
    def __init__(self, options: Options = ..., reporter: reporters.BaseReporter | reporters.MultiReporter | None = ..., option_groups: tuple[tuple[str, str], ...] = ..., pylintrc: str | None = ...) -> None:
        ...

    def load_default_plugins(self) -> None:
        ...

    def load_plugin_modules(self, modnames: Iterable[str], force: bool = ...) -> None:
        """Check a list of pylint plugins modules, load and register them.

        If a module cannot be loaded, never try to load it again and instead
        store the error message for later use in ``load_plugin_configuration``
        below.

        If `force` is True (useful when multiprocessing), then the plugin is
        reloaded regardless if an entry exists in self._dynamic_plugins.
        """
        ...

    def load_plugin_configuration(self) -> None:
        """Call the configuration hook for plugins.

        This walks through the list of plugins, grabs the "load_configuration"
        hook, if exposed, and calls it to allow plugins to configure specific
        settings.

        The result of attempting to load the plugin of the given name
        is stored in the dynamic plugins dictionary in ``load_plugin_modules`` above.

        ..note::
            This function previously always tried to load modules again, which
            led to some confusion and silent failure conditions as described
            in GitHub issue #7264. Making it use the stored result is more efficient, and
            means that we avoid the ``init-hook`` problems from before.
        """
        ...

    def set_reporter(self, reporter: reporters.BaseReporter | reporters.MultiReporter) -> None:
        """Set the reporter used to display messages and reports."""
        ...

    def register_reporter(self, reporter_class: type[reporters.BaseReporter]) -> None:
        """Registers a reporter class on the _reporters attribute."""
        ...

    def report_order(self) -> list[BaseChecker]:
        ...

    def register_checker(self, checker: checkers.BaseChecker) -> None:
        """This method auto registers the checker."""
        ...

    def enable_fail_on_messages(self) -> None:
        """Enable 'fail on' msgs.

        Convert values in config.fail_on (which might be msg category, msg id,
        or symbol) to specific msgs, then enable and flag them for later.
        """
        ...

    def any_fail_on_issues(self) -> bool:
        ...

    def disable_reporters(self) -> None:
        """Disable all reporters."""
        ...

    def get_checkers(self) -> list[BaseChecker]:
        """Return all available checkers as an ordered list."""
        ...

    def get_checker_names(self) -> list[str]:
        """Get all the checker names that this linter knows about."""
        ...

    def prepare_checkers(self) -> list[BaseChecker]:
        """Return checkers needed for activated messages and reports."""
        ...

    @staticmethod
    def should_analyze_file(modname: str, path: str, is_argument: bool = ...) -> bool:
        """Returns whether a module should be checked.

        This implementation returns True for all python source files (.py and .pyi),
        indicating that all files should be linted.

        Subclasses may override this method to indicate that modules satisfying
        certain conditions should not be linted.

        :param str modname: The name of the module to be checked.
        :param str path: The full path to the source code of the module.
        :param bool is_argument: Whether the file is an argument to pylint or not.
                                 Files which respect this property are always
                                 checked, since the user requested it explicitly.
        :returns: True if the module should be checked.
        """
        ...

    def initialize(self) -> None:
        """Initialize linter for linting.

        This method is called before any linting is done.
        """
        ...

    def check(self, files_or_modules: Sequence[str]) -> None:
        """Main checking entry: check a list of files or modules from their name.

        files_or_modules is either a string or list of strings presenting modules to check.
        """
        ...

    def check_single_file_item(self, file: FileItem) -> None:
        """Check single file item.

        The arguments are the same that are documented in _check_files

        initialize() should be called before calling this method
        """
        ...

    def set_current_module(self, modname: str, filepath: str | None = ...) -> None:
        """Set the name of the currently analyzed module and
        init statistics for it.
        """
        ...

    def get_ast(self, filepath: str, modname: str, data: str | None = ...) -> nodes.Module | None:
        """Return an ast(roid) representation of a module or a string.

        :param filepath: path to checked file.
        :param str modname: The name of the module to be checked.
        :param str data: optional contents of the checked file.
        :returns: the AST
        :rtype: astroid.nodes.Module
        :raises AstroidBuildingError: Whenever we encounter an unexpected exception
        """
        ...

    def check_astroid_module(self, ast_node: nodes.Module, walker: ASTWalker, rawcheckers: list[checkers.BaseRawFileChecker], tokencheckers: list[checkers.BaseTokenChecker]) -> bool | None:
        """Check a module from its astroid representation.

        For return value see _check_astroid_module
        """
        ...

    def open(self) -> None:
        """Initialize counters."""
        ...

    def generate_reports(self, verbose: bool = ...) -> int | None:
        """Close the whole package /module, it's time to make reports !

        if persistent run, pickle results for later comparison
        """
        ...

    def add_message(self, msgid: str, line: int | None = ..., node: nodes.NodeNG | None = ..., args: Any | None = ..., confidence: interfaces.Confidence | None = ..., col_offset: int | None = ..., end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """Adds a message given by ID or name.

        If provided, the message string is expanded using args.

        AST checkers must provide the node argument (but may optionally
        provide line if the line number is different), raw and token checkers
        must provide the line argument.
        """
        ...

    def add_ignored_message(self, msgid: str, line: int, node: nodes.NodeNG | None = ..., confidence: interfaces.Confidence | None = ...) -> None:
        """Prepares a message to be added to the ignored message storage.

        Some checks return early in special cases and never reach add_message(),
        even though they would normally issue a message.
        This creates false positives for useless-suppression.
        This function avoids this by adding those message to the ignored msgs attribute
        """
        ...
