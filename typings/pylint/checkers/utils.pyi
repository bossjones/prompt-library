"""
This type stub file was generated by pyright.
"""

import builtins
from collections.abc import Callable, Iterable, Iterator
from functools import lru_cache
from re import Match
from typing import TYPE_CHECKING, TypeVar
from astroid import nodes
from astroid.context import InferenceContext
from astroid.nodes._base_nodes import ImportNode, Statement
from astroid.typing import InferenceResult, SuccessfulInferenceResult
from pylint.checkers import BaseChecker

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
_NodeT = TypeVar("_NodeT", bound=nodes.NodeNG)
_CheckerT = TypeVar("_CheckerT", bound="BaseChecker")
AstCallbackMethod = Callable[[_CheckerT, _NodeT], None]
COMP_NODE_TYPES = ...
EXCEPTIONS_MODULE = ...
ABC_MODULES = ...
ABC_METHODS = ...
TYPING_PROTOCOLS = ...
COMMUTATIVE_OPERATORS = ...
ITER_METHOD = ...
AITER_METHOD = ...
NEXT_METHOD = ...
GETITEM_METHOD = ...
CLASS_GETITEM_METHOD = ...
SETITEM_METHOD = ...
DELITEM_METHOD = ...
CONTAINS_METHOD = ...
KEYS_METHOD = ...
_SPECIAL_METHODS_PARAMS = ...
SPECIAL_METHODS_PARAMS = ...
PYMETHODS = ...
SUBSCRIPTABLE_CLASSES_PEP585 = ...
SINGLETON_VALUES = ...
TERMINATING_FUNCS_QNAMES = ...
class NoSuchArgumentError(Exception):
    ...


class InferredTypeError(Exception):
    ...


def get_all_elements(node: nodes.NodeNG) -> Iterable[nodes.NodeNG]:
    """Recursively returns all atoms in nested lists and tuples."""
    ...

def is_super(node: nodes.NodeNG) -> bool:
    """Return True if the node is referencing the "super" builtin function."""
    ...

def is_error(node: nodes.FunctionDef) -> bool:
    """Return true if the given function node only raises an exception."""
    ...

builtins = ...
SPECIAL_BUILTINS = ...
def is_builtin_object(node: nodes.NodeNG) -> bool:
    """Returns True if the given node is an object from the __builtin__ module."""
    ...

def is_builtin(name: str) -> bool:
    """Return true if <name> could be considered as a builtin defined by python."""
    ...

def is_defined_in_scope(var_node: nodes.NodeNG, varname: str, scope: nodes.NodeNG) -> bool:
    ...

def defnode_in_scope(var_node: nodes.NodeNG, varname: str, scope: nodes.NodeNG) -> nodes.NodeNG | None:
    ...

def is_defined_before(var_node: nodes.Name) -> bool:
    """Check if the given variable node is defined before.

    Verify that the variable node is defined by a parent node
    (e.g. if or with) earlier than `var_node`, or is defined by a
    (list, set, dict, or generator comprehension, lambda)
    or in a previous sibling node on the same line
    (statement_defining ; statement_using).
    """
    ...

def is_default_argument(node: nodes.NodeNG, scope: nodes.NodeNG | None = ...) -> bool:
    """Return true if the given Name node is used in function or lambda
    default argument's value.
    """
    ...

def is_func_decorator(node: nodes.NodeNG) -> bool:
    """Return true if the name is used in function decorator."""
    ...

def is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -> bool:
    """Return whether `frame` is an astroid.Class node with `node` in the
    subtree of its bases attribute.
    """
    ...

def is_being_called(node: nodes.NodeNG) -> bool:
    """Return True if node is the function being called in a Call node."""
    ...

def assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:
    """Return the higher parent which is not an AssignName, Tuple or List node."""
    ...

def overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:
    """Return True if <name> is a method overridden from an ancestor
    which is not the base object class.
    """
    ...

def only_required_for_messages(*messages: str) -> Callable[[AstCallbackMethod[_CheckerT, _NodeT]], AstCallbackMethod[_CheckerT, _NodeT]]:
    """Decorator to store messages that are handled by a checker method as an
    attribute of the function object.

    This information is used by ``ASTWalker`` to decide whether to call the decorated
    method or not. If none of the messages is enabled, the method will be skipped.
    Therefore, the list of messages must be well maintained at all times!
    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods
    of a class inheriting from ``BaseChecker``.
    """
    ...

class IncompleteFormatString(Exception):
    """A format string ended in the middle of a format specifier."""
    ...


class UnsupportedFormatCharacter(Exception):
    """A format character in a format string is not one of the supported
    format characters.
    """
    def __init__(self, index: int) -> None:
        ...



def parse_format_string(format_string: str) -> tuple[set[str], int, dict[str, str], list[str]]:
    """Parses a format string, returning a tuple (keys, num_args).

    Where 'keys' is the set of mapping keys in the format string, and 'num_args' is the number
    of arguments required by the format string. Raises IncompleteFormatString or
    UnsupportedFormatCharacter if a parse error occurs.
    """
    ...

def split_format_field_names(format_string: str) -> tuple[str, Iterable[tuple[bool, str]]]:
    ...

def collect_string_fields(format_string: str) -> Iterable[str | None]:
    """Given a format string, return an iterator
    of all the valid format fields.

    It handles nested fields as well.
    """
    ...

def parse_format_method_string(format_string: str) -> tuple[list[tuple[str, list[tuple[bool, str]]]], int, int]:
    """Parses a PEP 3101 format string, returning a tuple of
    (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args).

    keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt
    is the number of arguments required by the format string and
    explicit_pos_args is the number of arguments passed with the position.
    """
    ...

def is_attr_protected(attrname: str) -> bool:
    """Return True if attribute name is protected (start with _ and some other
    details), False otherwise.
    """
    ...

def node_frame_class(node: nodes.NodeNG) -> nodes.ClassDef | None:
    """Return the class that is wrapping the given node.

    The function returns a class for a method node (or a staticmethod or a
    classmethod), otherwise it returns `None`.
    """
    ...

def get_outer_class(class_node: astroid.ClassDef) -> astroid.ClassDef | None:
    """Return the class that is the outer class of given (nested) class_node."""
    ...

def is_attr_private(attrname: str) -> Match[str] | None:
    """Check that attribute name is private (at least two leading underscores,
    at most one trailing underscore).
    """
    ...

def get_argument_from_call(call_node: nodes.Call, position: int | None = ..., keyword: str | None = ...) -> nodes.Name:
    """Returns the specified argument from a function call.

    :param nodes.Call call_node: Node representing a function call to check.
    :param int position: position of the argument.
    :param str keyword: the keyword of the argument.

    :returns: The node representing the argument, None if the argument is not found.
    :rtype: nodes.Name
    :raises ValueError: if both position and keyword are None.
    :raises NoSuchArgumentError: if no argument at the provided position or with
    the provided keyword.
    """
    ...

def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -> nodes.Name | None:
    """Returns the specified argument from a function's kwargs.

    :param nodes.Call call_node: Node representing a function call to check.
    :param str keyword: Name of the argument to be extracted.

    :returns: The node representing the argument, None if the argument is not found.
    :rtype: nodes.Name
    """
    ...

def inherit_from_std_ex(node: nodes.NodeNG | astroid.Instance) -> bool:
    """Return whether the given class node is subclass of
    exceptions.Exception.
    """
    ...

def error_of_type(handler: nodes.ExceptHandler, error_type: str | type[Exception] | tuple[str | type[Exception], ...]) -> bool:
    """Check if the given exception handler catches
    the given error_type.

    The *handler* parameter is a node, representing an ExceptHandler node.
    The *error_type* can be an exception, such as AttributeError,
    the name of an exception, or it can be a tuple of errors.
    The function will return True if the handler catches any of the
    given errors.
    """
    ...

def decorated_with_property(node: nodes.FunctionDef) -> bool:
    """Detect if the given function node is decorated with a property."""
    ...

def is_property_setter(node: nodes.NodeNG) -> bool:
    """Check if the given node is a property setter."""
    ...

def is_property_deleter(node: nodes.NodeNG) -> bool:
    """Check if the given node is a property deleter."""
    ...

def is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:
    """Check if the given node is either a property setter or a deleter."""
    ...

def decorated_with(func: (nodes.ClassDef | nodes.FunctionDef | astroid.BoundMethod | astroid.UnboundMethod), qnames: Iterable[str]) -> bool:
    """Determine if the `func` node has a decorator with the qualified name `qname`."""
    ...

def uninferable_final_decorators(node: nodes.Decorators) -> list[nodes.Attribute | nodes.Name | None]:
    """Return a list of uninferable `typing.final` decorators in `node`.

    This function is used to determine if the `typing.final` decorator is used
    with an unsupported Python version; the decorator cannot be inferred when
    using a Python version lower than 3.8.
    """
    ...

@lru_cache(maxsize=1024)
def unimplemented_abstract_methods(node: nodes.ClassDef, is_abstract_cb: nodes.FunctionDef | None = ...) -> dict[str, nodes.FunctionDef]:
    """Get the unimplemented abstract methods for the given *node*.

    A method can be considered abstract if the callback *is_abstract_cb*
    returns a ``True`` value. The check defaults to verifying that
    a method is decorated with abstract methods.
    It will return a dictionary of abstract method
    names and their inferred objects.
    """
    ...

def find_try_except_wrapper_node(node: nodes.NodeNG) -> nodes.ExceptHandler | nodes.Try | None:
    """Return the ExceptHandler or the Try node in which the node is."""
    ...

def find_except_wrapper_node_in_scope(node: nodes.NodeNG) -> nodes.ExceptHandler | None:
    """Return the ExceptHandler in which the node is, without going out of scope."""
    ...

def is_from_fallback_block(node: nodes.NodeNG) -> bool:
    """Check if the given node is from a fallback import block."""
    ...

def get_exception_handlers(node: nodes.NodeNG, exception: type[Exception] | str = ...) -> list[nodes.ExceptHandler] | None:
    """Return the collections of handlers handling the exception in arguments.

    Args:
        node (nodes.NodeNG): A node that is potentially wrapped in a try except.
        exception (builtin.Exception or str): exception or name of the exception.

    Returns:
        list: the collection of handlers that are handling the exception or None.
    """
    ...

def get_contextlib_with_statements(node: nodes.NodeNG) -> Iterator[nodes.With]:
    """Get all contextlib.with statements in the ancestors of the given node."""
    ...

def get_contextlib_suppressors(node: nodes.NodeNG, exception: type[Exception] | str = ...) -> Iterator[nodes.With]:
    """Return the contextlib suppressors handling the exception.

    Args:
        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.
        exception (builtin.Exception): exception or name of the exception.

    Yields:
        nodes.With: A with node that is suppressing the exception.
    """
    ...

def is_node_inside_try_except(node: nodes.Raise) -> bool:
    """Check if the node is directly under a Try/Except statement
    (but not under an ExceptHandler!).

    Args:
        node (nodes.Raise): the node raising the exception.

    Returns:
        bool: True if the node is inside a try/except statement, False otherwise.
    """
    ...

def node_ignores_exception(node: nodes.NodeNG, exception: type[Exception] | str = ...) -> bool:
    """Check if the node is in a Try which handles the given exception.

    If the exception is not given, the function is going to look for bare
    excepts.
    """
    ...

@lru_cache(maxsize=1024)
def class_is_abstract(node: nodes.ClassDef) -> bool:
    """Return true if the given class node should be considered as an abstract
    class.
    """
    ...

def is_comprehension(node: nodes.NodeNG) -> bool:
    ...

def is_inside_abstract_class(node: nodes.NodeNG) -> bool:
    ...

def is_iterable(value: nodes.NodeNG, check_async: bool = ...) -> bool:
    ...

def is_mapping(value: nodes.NodeNG) -> bool:
    ...

def supports_membership_test(value: nodes.NodeNG) -> bool:
    ...

def supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -> bool:
    ...

def supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:
    ...

def supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -> bool:
    ...

@lru_cache(maxsize=1024)
def safe_infer(node: nodes.NodeNG, context: InferenceContext | None = ..., *, compare_constants: bool = ..., compare_constructors: bool = ...) -> InferenceResult | None:
    """Return the inferred value for the given node.

    Return None if inference failed or if there is some ambiguity (more than
    one node has been inferred of different types).

    If compare_constants is True and if multiple constants are inferred,
    unequal inferred values are also considered ambiguous and return None.

    If compare_constructors is True and if multiple classes are inferred,
    constructors with different signatures are held ambiguous and return None.
    """
    ...

@lru_cache(maxsize=512)
def infer_all(node: nodes.NodeNG, context: InferenceContext | None = ...) -> list[InferenceResult]:
    ...

def function_arguments_are_ambiguous(func1: nodes.FunctionDef, func2: nodes.FunctionDef) -> bool:
    ...

def class_constructors_are_ambiguous(class1: nodes.ClassDef, class2: nodes.ClassDef) -> bool:
    ...

def has_known_bases(klass: nodes.ClassDef, context: InferenceContext | None = ...) -> bool:
    """Return true if all base classes of a class could be inferred."""
    ...

def is_none(node: nodes.NodeNG) -> bool:
    ...

def node_type(node: nodes.NodeNG) -> SuccessfulInferenceResult | None:
    """Return the inferred type for `node`.

    If there is more than one possible type, or if inferred type is Uninferable or None,
    return None
    """
    ...

def is_registered_in_singledispatch_function(node: nodes.FunctionDef) -> bool:
    """Check if the given function node is a singledispatch function."""
    ...

def find_inferred_fn_from_register(node: nodes.NodeNG) -> nodes.FunctionDef | None:
    ...

def is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef) -> bool:
    """Check if the given function node is a singledispatchmethod function."""
    ...

def get_node_last_lineno(node: nodes.NodeNG) -> int:
    """Get the last lineno of the given node.

    For a simple statement this will just be node.lineno,
    but for a node that has child statements (e.g. a method) this will be the lineno of the last
    child statement recursively.
    """
    ...

def is_postponed_evaluation_enabled(node: nodes.NodeNG) -> bool:
    """Check if the postponed evaluation of annotations is enabled."""
    ...

def is_node_in_type_annotation_context(node: nodes.NodeNG) -> bool:
    """Check if node is in type annotation context.

    Check for 'AnnAssign', function 'Arguments',
    or part of function return type annotation.
    """
    ...

def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:
    """Check if first node is a subclass of second node.

    :param child: Node to check for subclass.
    :param parent: Node to check for superclass.
    :returns: True if child is derived from parent. False otherwise.
    """
    ...

@lru_cache(maxsize=1024)
def is_overload_stub(node: nodes.NodeNG) -> bool:
    """Check if a node is a function stub decorated with typing.overload.

    :param node: Node to check.
    :returns: True if node is an overload function stub. False otherwise.
    """
    ...

def is_protocol_class(cls: nodes.NodeNG) -> bool:
    """Check if the given node represents a protocol class.

    :param cls: The node to check
    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.
    """
    ...

def is_call_of_name(node: nodes.NodeNG, name: str) -> bool:
    """Checks if node is a function call with the given name."""
    ...

def is_test_condition(node: nodes.NodeNG, parent: nodes.NodeNG | None = ...) -> bool:
    """Returns true if the given node is being tested for truthiness."""
    ...

def is_classdef_type(node: nodes.ClassDef) -> bool:
    """Test if ClassDef node is Type."""
    ...

def is_attribute_typed_annotation(node: nodes.ClassDef | astroid.Instance, attr_name: str) -> bool:
    """Test if attribute is typed annotation in current node
    or any base nodes.
    """
    ...

def is_enum(node: nodes.ClassDef) -> bool:
    ...

def is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:
    """Test if AssignName node has `typing_name` annotation.

    Especially useful to check for `typing._SpecialForm` instances
    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.
    """
    ...

def get_iterating_dictionary_name(node: nodes.For | nodes.Comprehension) -> str | None:
    """Get the name of the dictionary which keys are being iterated over on
    a ``nodes.For`` or ``nodes.Comprehension`` node.

    If the iterating object is not either the keys method of a dictionary
    or a dictionary itself, this returns None.
    """
    ...

def get_subscript_const_value(node: nodes.Subscript) -> nodes.Const:
    """Returns the value 'subscript.slice' of a Subscript node.

    :param node: Subscript Node to extract value from
    :returns: Const Node containing subscript value
    :raises InferredTypeError: if the subscript node cannot be inferred as a Const
    """
    ...

def get_import_name(importnode: ImportNode, modname: str | None) -> str | None:
    """Get a prepared module name from the given import node.

    In the case of relative imports, this will return the
    absolute qualified module name, which might be useful
    for debugging. Otherwise, the initial module name
    is returned unchanged.

    :param importnode: node representing import statement.
    :param modname: module name from import statement.
    :returns: absolute qualified module name of the module
        used in import.
    """
    ...

def is_sys_guard(node: nodes.If) -> bool:
    """Return True if IF stmt is a sys.version_info guard.

    >>> import sys
    >>> from typing import Literal
    """
    ...

def is_reassigned_after_current(node: nodes.NodeNG, varname: str) -> bool:
    """Check if the given variable name is reassigned in the same scope after the
    current node.
    """
    ...

def is_deleted_after_current(node: nodes.NodeNG, varname: str) -> bool:
    """Check if the given variable name is deleted in the same scope after the current
    node.
    """
    ...

def is_function_body_ellipsis(node: nodes.FunctionDef) -> bool:
    """Checks whether a function body only consists of a single Ellipsis."""
    ...

def is_base_container(node: nodes.NodeNG | None) -> bool:
    ...

def is_empty_dict_literal(node: nodes.NodeNG | None) -> bool:
    ...

def is_empty_str_literal(node: nodes.NodeNG | None) -> bool:
    ...

def returns_bool(node: nodes.NodeNG) -> bool:
    """Returns true if a node is a nodes.Return that returns a constant boolean."""
    ...

def assigned_bool(node: nodes.NodeNG) -> bool:
    """Returns true if a node is a nodes.Assign that returns a constant boolean."""
    ...

def get_node_first_ancestor_of_type(node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]) -> _NodeT | None:
    """Return the first parent node that is any of the provided types (or None)."""
    ...

def get_node_first_ancestor_of_type_and_its_child(node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]) -> tuple[None, None] | tuple[_NodeT, nodes.NodeNG]:
    """Modified version of get_node_first_ancestor_of_type to also return the
    descendant visited directly before reaching the sought ancestor.

    Useful for extracting whether a statement is guarded by a try, except, or finally
    when searching for a Try ancestor.
    """
    ...

def in_type_checking_block(node: nodes.NodeNG) -> bool:
    """Check if a node is guarded by a TYPE_CHECKING guard."""
    ...

def is_typing_member(node: nodes.NodeNG, names_to_check: tuple[str, ...]) -> bool:
    """Check if `node` is a member of the `typing` module and has one of the names from
    `names_to_check`.
    """
    ...

@lru_cache
def in_for_else_branch(parent: nodes.NodeNG, stmt: Statement) -> bool:
    """Returns True if stmt is inside the else branch for a parent For stmt."""
    ...

def find_assigned_names_recursive(target: nodes.AssignName | nodes.BaseContainer) -> Iterator[str]:
    """Yield the names of assignment targets, accounting for nested ones."""
    ...

def has_starred_node_recursive(node: nodes.For | nodes.Comprehension | nodes.Set) -> Iterator[bool]:
    """Yield ``True`` if a Starred node is found recursively."""
    ...

def is_hashable(node: nodes.NodeNG) -> bool:
    """Return whether any inferred value of `node` is hashable.

    When finding ambiguity, return True.
    """
    ...

def subscript_chain_is_equal(left: nodes.Subscript, right: nodes.Subscript) -> bool:
    ...

def is_augmented_assign(node: nodes.Assign) -> tuple[bool, str]:
    """Determine if the node is assigning itself (with modifications) to itself.

    For example: x = 1 + x
    """
    ...

def is_module_ignored(qualified_module_name: str, ignored_modules: Iterable[str]) -> bool:
    ...

def is_singleton_const(node: nodes.NodeNG) -> bool:
    ...

def is_terminating_func(node: nodes.Call) -> bool:
    """Detect call to exit(), quit(), os._exit(), sys.exit(), or
    functions annotated with `typing.NoReturn` or `typing.Never`.
    """
    ...

def is_class_attr(name: str, klass: nodes.ClassDef) -> bool:
    ...

def get_inverse_comparator(op: str) -> str:
    """Returns the inverse comparator given a comparator.

    E.g. when given "==", returns "!="

    :param str op: the comparator to look up.

    :returns: The inverse of the comparator in string format
    :raises KeyError: if input is not recognized as a comparator
    """
    ...

def not_condition_as_string(test_node: nodes.Compare | nodes.Name | nodes.UnaryOp | nodes.BoolOp | nodes.BinOp) -> str:
    ...

@lru_cache(maxsize=1000)
def overridden_method(klass: nodes.LocalsDictNodeNG, name: str | None) -> nodes.FunctionDef | None:
    """Get overridden method if any."""
    ...

def clear_lru_caches() -> None:
    """Clear caches holding references to AST nodes."""
    ...

def is_enum_member(node: nodes.AssignName) -> bool:
    """Return `True` if `node` is an Enum member (is an item of the
    `__members__` container).
    """
    ...
