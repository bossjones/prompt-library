"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import Optional
from astroid import nodes
from pylint.pyreverse import utils

"""
This type stub file was generated by pyright.
"""
_WrapperFuncT = Callable[[Callable[[str], nodes.Module], str, bool], Optional[nodes.Module]]
class IdGeneratorMixIn:
    """Mixin adding the ability to generate integer uid."""
    def __init__(self, start_value: int = ...) -> None:
        ...
    
    def init_counter(self, start_value: int = ...) -> None:
        """Init the id counter."""
        ...
    
    def generate_id(self) -> int:
        """Generate a new identifier."""
        ...
    


class Project:
    """A project handle a set of modules / packages."""
    def __init__(self, name: str = ...) -> None:
        ...
    
    def add_module(self, node: nodes.Module) -> None:
        ...
    
    def get_module(self, name: str) -> nodes.Module:
        ...
    
    def get_children(self) -> list[nodes.Module]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
    """Walk on the project tree and resolve relationships.

    According to options the following attributes may be
    added to visited nodes:

    * uid,
      a unique identifier for the node (on astroid.Project, astroid.Module,
      astroid.Class and astroid.locals_type). Only if the linker
      has been instantiated with tag=True parameter (False by default).

    * Function
      a mapping from locals names to their bounded value, which may be a
      constant like a string or an integer, or an astroid node
      (on astroid.Module, astroid.Class and astroid.Function).

    * instance_attrs_type
      as locals_type but for klass member attributes (only on astroid.Class)

    * associations_type
      as instance_attrs_type but for association relationships

    * aggregations_type
      as instance_attrs_type but for aggregations relationships
    """
    def __init__(self, project: Project, tag: bool = ...) -> None:
        ...
    
    def visit_project(self, node: Project) -> None:
        """Visit a pyreverse.utils.Project node.

        * optionally tag the node with a unique id
        """
        ...
    
    def visit_module(self, node: nodes.Module) -> None:
        """Visit an astroid.Module node.

        * set the locals_type mapping
        * set the depends mapping
        * optionally tag the node with a unique id
        """
        ...
    
    def visit_classdef(self, node: nodes.ClassDef) -> None:
        """Visit an astroid.Class node.

        * set the locals_type and instance_attrs_type mappings
        * optionally tag the node with a unique id
        """
        ...
    
    def visit_functiondef(self, node: nodes.FunctionDef) -> None:
        """Visit an astroid.Function node.

        * set the locals_type mapping
        * optionally tag the node with a unique id
        """
        ...
    
    def visit_assignname(self, node: nodes.AssignName) -> None:
        """Visit an astroid.AssignName node.

        handle locals_type
        """
        ...
    
    @staticmethod
    def handle_assignattr_type(node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:
        """Handle an astroid.assignattr node.

        handle instance_attrs_type
        """
        ...
    
    def visit_import(self, node: nodes.Import) -> None:
        """Visit an astroid.Import node.

        resolve module dependencies
        """
        ...
    
    def visit_importfrom(self, node: nodes.ImportFrom) -> None:
        """Visit an astroid.ImportFrom node.

        resolve module dependencies
        """
        ...
    
    def compute_module(self, context_name: str, mod_path: str) -> bool:
        """Should the module be added to dependencies ?"""
        ...
    


class AssociationHandlerInterface(ABC):
    @abstractmethod
    def set_next(self, handler: AssociationHandlerInterface) -> AssociationHandlerInterface:
        ...
    
    @abstractmethod
    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:
        ...
    


class AbstractAssociationHandler(AssociationHandlerInterface):
    """
    Chain of Responsibility for handling types of association, useful
    to expand in the future if we want to add more distinct associations.

    Every link of the chain checks if it's a certain type of association.
    If no association is found it's set as a generic association in `associations_type`.

    The default chaining behavior is implemented inside the base handler
    class.
    """
    _next_handler: AssociationHandlerInterface
    def set_next(self, handler: AssociationHandlerInterface) -> AssociationHandlerInterface:
        ...
    
    @abstractmethod
    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:
        ...
    


class AggregationsHandler(AbstractAssociationHandler):
    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:
        ...
    


class OtherAssociationsHandler(AbstractAssociationHandler):
    def handle(self, node: nodes.AssignAttr, parent: nodes.ClassDef) -> None:
        ...
    


def project_from_files(files: list[str], func_wrapper: _WrapperFuncT = ..., project_name: str = ..., black_list: tuple[str, ...] = ..., verbose: bool = ...) -> Project:
    """Return a Project from a list of files or modules."""
    ...

