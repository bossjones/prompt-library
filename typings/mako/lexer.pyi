"""
This type stub file was generated by pyright.
"""

"""provides the Lexer class for parsing template strings into parse trees."""
_regexp_cache = ...
class Lexer:
    def __init__(self, text, filename=..., input_encoding=..., preprocessor=...) -> None:
        ...

    @property
    def exception_kwargs(self): # -> dict[str, Any]:
        ...

    def match(self, regexp, flags=...): # -> Match[str] | None:
        """compile the given regexp, cache the reg, and call match_reg()."""
        ...

    def match_reg(self, reg):
        """match the given regular expression object to the current text
        position.

        if a match occurs, update the current text and line position.

        """
        ...

    def parse_until_text(self, watch_nesting, *text): # -> tuple[Any | str, str | Any]:
        ...

    def append_node(self, nodecls, *args, **kwargs): # -> None:
        ...

    _coding_re = ...
    def decode_raw_stream(self, text, decode_raw, known_encoding, filename): # -> tuple[str | Any, str] | tuple[str | Any, Any]:
        """given string/unicode or bytes/string, determine encoding
        from magic encoding comment, return body as unicode
        or raw if decode_raw=False

        """
        ...

    def parse(self): # -> TemplateNode:
        ...

    def match_tag_start(self): # -> bool:
        ...

    def match_tag_end(self): # -> bool:
        ...

    def match_end(self): # -> str | bool:
        ...

    def match_percent(self): # -> bool:
        ...

    def match_text(self): # -> bool:
        ...

    def match_python_block(self): # -> bool:
        ...

    def match_expression(self): # -> bool:
        ...

    def match_control_line(self): # -> bool:
        ...

    def match_comment(self): # -> bool:
        """matches the multiline version of a comment"""
        ...
