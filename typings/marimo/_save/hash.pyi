"""
This type stub file was generated by pyright.
"""

import ast
from typing import Any, Iterable, NamedTuple, Optional, TYPE_CHECKING
from marimo._ast.visitor import Name
from marimo._save.cache import Cache
from types import CodeType
from marimo._ast.cell import CellId_t, CellImpl
from marimo._runtime.context.types import RuntimeContext
from marimo._runtime.dataflow import DirectedGraph
from marimo._save.loaders import Loader

if TYPE_CHECKING:
    Tensor = Any
DEFAULT_HASH = ...
class SerialRefs(NamedTuple):
    refs: set[Name]
    content_serialization: dict[Name, bytes]
    stateful_refs: set[Name]
    ...


class ShadowedRef:
    """Stub for scoped variables that may shadow global references"""
    ...


def hash_module(code: Optional[CodeType], hash_type: str = ...) -> bytes:
    ...

def hash_raw_module(module: ast.Module, hash_type: str = ...) -> bytes:
    ...

def hash_cell_impl(cell: CellImpl, hash_type: str = ...) -> bytes:
    ...

def standardize_tensor(tensor: Tensor) -> Optional[Tensor]:
    ...

def type_sign(value: bytes, label: str) -> bytes:
    ...

def iterable_sign(value: Iterable[Any], label: str) -> bytes:
    ...

def primitive_to_bytes(value: Any) -> bytes:
    ...

def common_container_to_bytes(value: Any) -> bytes:
    ...

def data_to_buffer(data: Tensor) -> bytes:
    ...

def attempt_signed_bytes(value: bytes, label: str) -> bytes:
    ...

def get_and_update_context_from_scope(scope: dict[str, Any], scope_refs: Optional[set[Name]] = ...) -> Optional[RuntimeContext]:
    """Get stateful registers"""
    ...

class BlockHasher:
    def __init__(self, module: ast.Module, graph: DirectedGraph, cell_id: CellId_t, scope: dict[str, Any], *, context: Optional[ast.Module] = ..., pin_modules: bool = ..., hash_type: str = ..., apply_content_hash: bool = ..., scoped_refs: Optional[set[Name]] = ...) -> None:
        """Hash the context of the module, and return a cache object.

        Hashing uses 3 combined methods: pure hashing, content addressed, and
        execution path:

        1) "Pure" hashing is used when a block has no references. The hash is
        computed from the code itself.

        2) "Content Addressed" hashing is used when all references are known
        and are shown to be primitive types (like a "pure" function).

        3) "Execution Path" hashing is when objects may contain state or other
        hidden values that are difficult to hash deterministically. For this,
        the code used to produce the object is used as the basis of the hash.
        It follows that code which does not change, will produce the same
        output. This draws inspiration from hashing methods in Nix. One notable
        difference between these methods is that Nix sandboxes all execution,
        preventing external file access, and internet. Sources of
        non-determinism are not accounted for in this implementation, and are
        left to the user.

        In both cases, as long as the module is deterministic, the output will
        be deterministic. NB. The ContextExecutionPath is an extended case of
        ExecutionPath hashing, just utilizing additional context.

        For optimization, the content hash is performed after the execution
        cache- however the content references are collected first. This
        deferred content hash is useful in cases like repeated calls to a
        cached function.

        Args:
          - module: The code content to create a hash for (e.g.
            for persistent_cache, the body of the `With` statement).
          - graph: The dataflow graph of the notebook.
          - cell_id: The cell id attached to the module.
          - scope: The definitions of (globals) available in execution context.
          - context: The "context" of the module, is a module corresponding
            additional execution context for the cell. For instance, in
            persistent_cache case, this applies to the code prior to
            invocation, but still in the same cell.
          - pin_modules: If True, then the module will be pinned to the version
          - hash_type: The type of hash to use.
          - apply_content_hash: If True, then the content hash will be
            attempted, otherwise only use execution path hash.
          - scoped_refs: A set of references that cannot be traced via
            execution path, and must be accounted for via content hashing.
        """
        ...

    @staticmethod
    def from_parent(parent: BlockHasher) -> BlockHasher:
        ...

    @property
    def hash(self) -> str:
        ...

    def __hash__(self) -> int:
        ...

    def collect_for_content_hash(self, refs: set[Name], scope: dict[str, Any], ctx: Optional[RuntimeContext], scoped_refs: set[Name], apply_hash: bool = ...) -> SerialRefs:
        ...

    def extract_missing_ref(self, refs: set[Name], scope: dict[str, Any]) -> tuple[set[Name], set[Name]]:
        ...

    def extract_ref_state_and_normalize_scope(self, refs: set[Name], scope: dict[str, Any], ctx: Optional[RuntimeContext] = ...) -> SerialRefs:
        """
        Preprocess the scope and references, and extract state references.

        This method performs the following operations:
        1. Removes references that are not present in the scope.
        2. Identifies and returns stateful references.
        3. Adjusts the scope, replacing UI elements and state setters with
           their corresponding values.

        Args:
            refs: A set of reference names.
            scope: A dictionary representing the current scope.
            ctx: An optional runtime context for stateful lookup.

        Returns:
            SerialRefs tuple containing the following elements:
                - The filtered references.
                - _
                - The stateful references.
        """
        ...

    def serialize_and_dequeue_content_refs(self, refs: set[Name], scope: dict[Name, Any]) -> SerialRefs:
        """Use hashable references to update the hash object and dequeue them.

        NB. "Hashable" types are primitives, data primitives, and pure
        functions. With modules being "hashed" by version number, or ignored.

        Args:
            refs: A set of reference names unaccounted for.
            scope: A dictionary representing the current scope.

        Returns a filtered list of remaining references that were not utilized
        in updating the hash, and a dictionary of the content serialization.
        """
        ...

    def serialize_and_dequeue_stateful_content_refs(self, refs: set[Name], scope: dict[str, Any], ctx: RuntimeContext) -> SerialRefs:
        """Determines and uses stateful references that impact the code block.

        Args:
            refs: A set of reference names.
            scope: A dictionary representing the current scope.
            ctx: Runtime context for stateful lookup.

        Returns:
            tuple of:
                - The updated references.
                - A dictionary of the content serialization.
                - additional stateful references.
        """
        ...

    def hash_and_dequeue_execution_refs(self, refs: set[Name]) -> set[Name]:
        """Determines and uses the hash of refs' cells to update the hash.

        Args:
          refs: List of references to account for in cell lookup.

        Returns a list of references that were not utilized in updating the
        hash. This should only be possible in the case where a cell context is
        provided, as those references should be accounted for in that context.
        """
        ...

    def hash_and_verify_context_refs(self, refs: set[Name], context: Optional[ast.Module]) -> None:
        """Utilizes the provided context to update the hash with sanity check.

        If there are remaining references, they must be part of the provided
        context. This ensures this is the case, and updates the hash.

        Args:
          refs: List of references to account for in cell lookup.
          context: The context of the module, is a module corresponding
            additional execution context for the cell. For instance, in
            persistent_cache case, this applies to the code prior to
            invocation, but still in the same cell.
        """
        ...



def cache_attempt_from_hash(module: ast.Module, graph: DirectedGraph, cell_id: CellId_t, scope: dict[str, Any], *, context: Optional[ast.Module] = ..., pin_modules: bool = ..., hash_type: str = ..., scoped_refs: Optional[set[Name]] = ..., loader: Loader, as_fn: bool = ...) -> Cache:
    """Hash a code block with context from the same cell, and return a cache
    object.

    Extra args
          - loader: The loader to use for cache operations.
          - as_fn: If True, then the block is treated as a function

    Returns:
      - A cache object that may, or may not be fully populated.
    """
    ...

def content_cache_attempt_from_base(previous_block: BlockHasher, scope: dict[str, Any], loader: Loader, scoped_refs: Optional[set[Name]] = ..., required_refs: Optional[set[Name]] = ..., *, as_fn: bool = ..., sensitive: bool = ...) -> Cache:
    """Hash a code block with context from the same cell, and attempt a cache
    lookup.

    Args:
      - previous_block: The block to base the new block on.
      - scope: The scope of the new block.
      - loader: The loader to use for cache operations.
      - scoped_refs: A set of references that cannot be traced via
        execution path, and must be accounted for via content hashing.
      - as_fn: If True, then the block is treated as a function, and will not
        cache definitions in scope.
      - sensitive: If True, then the cache hash will to rehash references
        resolved with path execution. This will invalidate the cache more
        frequently.
    """
    ...
