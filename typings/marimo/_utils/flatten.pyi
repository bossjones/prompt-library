"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, List, Tuple, Union

"""Flatten and repack nested structures of lists, tuples, and dicts

Adapted from https://github.com/ericmjl/pyflatten/tree/master; changed
to handle generic leaf data types and minimize recursion stack depth.

TODO(akshayka): if this becomes a bottleneck, use a library like dm-tree
(this implementation will be slow large structures); as of writing,
installation of dm-tree on macOS is buggy
"""
STRUCT_TYPE = Union[Tuple[Any, ...], List[Any], Dict[Any, Any]]
UNFLATTEN_TYPE = Callable[[List[Any]], Union[STRUCT_TYPE, Any]]
FLATTEN_RET_TYPE = Tuple[List[Any], UNFLATTEN_TYPE]
class CyclicStructureError(Exception):
    ...


def flatten(value: Any, json_compat_keys: bool = ...) -> FLATTEN_RET_TYPE:
    """Flatten a nested structure.

    Returns the structure flattened and a repacking function.

    Replacing function expects a flat list of the same length as
    the flattened structure.

    Usage:

    ```python
    value = [1, [2, 3], {"4": [5, 6]}, []]
    flattened, unflattener = flatten(value)
    # apply a map or other processing to each value of flattened ...
    # ...
    # packed_as_value has same nesting structure as value
    packed_as_value = unflattener(processed_flattened)
    ```

    Args:
    ----
    value: nested structure of lists, tuples, and dicts
    json_compat_keys: if True, unflattener will stringify dict keys when
      keys are not JSON compatible

    Returns:
    -------
    flattened_value, unflattener function

    Raises:
    ------
    CyclicStructureError: If the structure has a cyclic nesting pattern,
        such as a list that contains itself
    """
    ...

def contains_instance(value: Any, instance: Any) -> bool:
    """
    Recursively checks if value contains the given instance
    """
    ...
