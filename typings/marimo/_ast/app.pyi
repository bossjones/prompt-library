"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, Callable, Iterable, Iterator, List, Literal, Mapping, Optional, TYPE_CHECKING
from marimo._ast.cell import Cell, CellConfig, CellId_t
from marimo._config.config import WidthType
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._runtime import dataflow
from marimo._runtime.context.types import ExecutionContext
from marimo._runtime.requests import FunctionCallRequest, SetUIElementValueRequest
from collections.abc import Sequence
from marimo._messaging.ops import HumanReadableStatus
from marimo._plugins.core.web_component import JSONType

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
LOGGER = ...
DEFAULT_CELL_NAME = ...
def is_default_cell_name(name: str) -> bool:
    ...

@dataclass
class _AppConfig:
    """Program-specific configuration.

    Configuration for frontends or runtimes that is specific to
    a single marimo program.
    """
    width: WidthType = ...
    app_title: Optional[str] = ...
    layout_file: Optional[str] = ...
    css_file: Optional[str] = ...
    html_head_file: Optional[str] = ...
    auto_download: List[Literal["html", "markdown"]] = ...
    @staticmethod
    def from_untrusted_dict(updates: dict[str, Any]) -> _AppConfig:
        ...
    
    def asdict(self) -> dict[str, Any]:
        ...
    
    def update(self, updates: dict[str, Any]) -> _AppConfig:
        ...
    


@dataclass
class CellData:
    """A cell together with some metadata"""
    cell_id: CellId_t
    code: str
    name: str
    config: CellConfig
    cell: Optional[Cell]
    ...


class _Namespace(Mapping[str, object]):
    def __init__(self, dictionary: dict[str, object], owner: Cell | App) -> None:
        ...
    
    def __getitem__(self, item: str) -> object:
        ...
    
    def __iter__(self) -> Iterator[str]:
        ...
    
    def __len__(self) -> int:
        ...
    


@dataclass
class AppEmbedResult:
    output: Html
    defs: Mapping[str, object]
    ...


@mddoc
class App:
    """A marimo notebook.

    A marimo notebook is a dataflow graph, with each node computing a Python
    function.
    """
    def __init__(self, **kwargs: Any) -> None:
        ...
    
    def cell(self, func: Callable[..., Any] | None = ..., *, column: Optional[int] = ..., disabled: bool = ..., hide_code: bool = ..., **kwargs: Any) -> Cell | Callable[[Callable[..., Any]], Cell]:
        """A decorator to add a cell to the app

        This decorator can be called with or without parentheses. Each of the
        following is valid:

        ```
        @app.cell
        def __(mo):
            # ...

        @app.cell()
        def __(mo):
            # ...

        @app.cell(disabled=True)
        def __(mo):
            # ...
        ```

        Args:
        - func: The decorated function
        - disabled: Whether to disable the cell
        - kwargs: For forward-compatibility with future arguments
        """
        ...
    
    def run(self) -> tuple[Sequence[Any], Mapping[str, Any]]:
        ...
    
    @mddoc
    async def embed(self) -> AppEmbedResult:
        """Embed a notebook into another notebook.

        The `embed` method lets you embed the output of a notebook
        into another notebook and access the values of its variables.

        **Example.**

        ```python
        from my_notebook import app
        ```

        ```python
        # execute the notebook; app.embed() can't be called in the cell
        # that imported it!
        result = await app.embed()
        ```

        ```python
        # view the notebook's visual output
        result.output
        ```

        ```python
        # access the notebook's defined variables
        result.defs
        ```

        Running `await app.embed()` executes the notebook and results an object
        encapsulating the notebook visual output and its definitions.

        Embedded notebook outputs are interactive: when you interact with
        UI elements in an embedded notebook's output, any cell referring
        to the `app` object other than the one that imported it is marked for
        execution, and its internal state is automatically updated. This lets
        you use notebooks as building blocks or components to create
        higher-level notebooks.

        Multiple levels of nesting are supported: it's possible to embed a
        notebook that in turn embeds another notebook, and marimo will do the
        right thing.

        **Returns.**

        - An object `result` with two attributes: `result.output` (visual
          output of the notebook) and `result.defs` (a dictionary mapping
          variable names defined by the notebook to their values).
        """
        ...
    


class CellManager:
    """
    A manager for cells.

    This holds the cells that have been registered with the app, and
    provides methods to access them.
    """
    def __init__(self, prefix: str = ...) -> None:
        ...
    
    def create_cell_id(self) -> CellId_t:
        ...
    
    def cell_decorator(self, func: Callable[..., Any] | None, column: Optional[int], disabled: bool, hide_code: bool, app: InternalApp | None = ...) -> Cell | Callable[..., Cell]:
        ...
    
    def register_cell(self, cell_id: Optional[CellId_t], code: str, config: Optional[CellConfig], name: str = ..., cell: Optional[Cell] = ...) -> None:
        ...
    
    def register_unparsable_cell(self, code: str, name: Optional[str], cell_config: CellConfig) -> None:
        ...
    
    def ensure_one_cell(self) -> None:
        ...
    
    def cell_name(self, cell_id: CellId_t) -> str:
        ...
    
    def names(self) -> Iterable[str]:
        ...
    
    def codes(self) -> Iterable[str]:
        ...
    
    def configs(self) -> Iterable[CellConfig]:
        ...
    
    def valid_cells(self) -> Iterable[tuple[CellId_t, Cell]]:
        """Return cells and functions for each valid cell."""
        ...
    
    def valid_cell_ids(self) -> Iterable[CellId_t]:
        ...
    
    def cell_ids(self) -> Iterable[CellId_t]:
        """Cell IDs in the order they were registered."""
        ...
    
    def cells(self) -> Iterable[Optional[Cell]]:
        ...
    
    def config_map(self) -> dict[CellId_t, CellConfig]:
        ...
    
    def cell_data(self) -> Iterable[CellData]:
        ...
    
    def cell_data_at(self, cell_id: CellId_t) -> CellData:
        ...
    
    def get_cell_id_by_code(self, code: str) -> Optional[CellId_t]:
        """
        Finds the first cell with the given code and returns its cell ID.
        """
        ...
    


class InternalApp:
    """
    Internal representation of an app.

    This exposes private APIs that are used by the server and other
    internal components.
    """
    def __init__(self, app: App) -> None:
        ...
    
    @property
    def config(self) -> _AppConfig:
        ...
    
    @property
    def cell_manager(self) -> CellManager:
        ...
    
    @property
    def graph(self) -> dataflow.DirectedGraph:
        ...
    
    @property
    def execution_order(self) -> list[CellId_t]:
        ...
    
    @property
    def execution_context(self) -> ExecutionContext | None:
        ...
    
    def set_execution_context(self, execution_context: ExecutionContext | None) -> None:
        ...
    
    @property
    def runner(self) -> dataflow.Runner:
        ...
    
    def update_config(self, updates: dict[str, Any]) -> _AppConfig:
        ...
    
    def with_data(self, *, cell_ids: Iterable[CellId_t], codes: Iterable[str], names: Iterable[str], configs: Iterable[CellConfig]) -> InternalApp:
        ...
    
    async def run_cell_async(self, cell: Cell, kwargs: dict[str, Any]) -> tuple[Any, _Namespace]:
        ...
    
    def run_cell_sync(self, cell: Cell, kwargs: dict[str, Any]) -> tuple[Any, _Namespace]:
        ...
    
    async def set_ui_element_value(self, request: SetUIElementValueRequest) -> bool:
        ...
    
    async def function_call(self, request: FunctionCallRequest) -> tuple[HumanReadableStatus, JSONType, bool]:
        ...
    


