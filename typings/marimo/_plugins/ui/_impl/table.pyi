"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, Callable, Dict, Final, List, Literal, Optional, Sequence, Union
from narwhals.typing import IntoDataFrame
from marimo._data.models import NonNestedLiteral
from marimo._output.mime import MIME
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._plugins.ui._core.ui_element import UIElement
from marimo._plugins.ui._impl.dataframes.transforms.types import Condition
from marimo._plugins.ui._impl.tables.table_manager import ColumnName
from marimo._plugins.ui._impl.utils.dataframe import ListOrTuple, TableData
from marimo._runtime.functions import EmptyArgs

"""
This type stub file was generated by pyright.
"""
LOGGER = ...
@dataclass
class DownloadAsArgs:
    format: Literal["csv", "json"]
    ...


@dataclass
class ColumnSummary:
    column: str
    nulls: Optional[int]
    min: Optional[NonNestedLiteral]
    max: Optional[NonNestedLiteral]
    unique: Optional[int]
    true: Optional[NonNestedLiteral] = ...
    false: Optional[NonNestedLiteral] = ...


@dataclass
class ColumnSummaries:
    data: Union[JSONType, str]
    summaries: List[ColumnSummary]
    is_disabled: Optional[bool] = ...


@dataclass(frozen=True)
class SearchTableArgs:
    page_size: int
    page_number: int
    query: Optional[str] = ...
    sort: Optional[SortArgs] = ...
    filters: Optional[List[Condition]] = ...
    limit: Optional[int] = ...


@dataclass(frozen=True)
class SearchTableResponse:
    data: Union[JSONType, str]
    total_rows: int
    ...


@dataclass(frozen=True)
class SortArgs:
    by: ColumnName
    descending: bool
    ...


@mddoc
class table(UIElement[List[str], Union[List[JSONType], IntoDataFrame]]):
    """
    A table component with selectable rows. Get the selected rows with
    `table.value`.

    The table data can be supplied a:

    1. a list of dicts, with one dict for each row, keyed by column names;
    2. a list of values, representing a table with a single column;
    3. a Pandas dataframe; or
    4. a Polars dataframe; or
    5. an Ibis dataframe; or
    6. a PyArrow table.

    **Examples.**

    Create a table from a list of dicts, one for each row.

    ```python
    table = mo.ui.table(
        data=[
            {"first_name": "Michael", "last_name": "Scott"},
            {"first_name": "Dwight", "last_name": "Schrute"},
        ],
        label="Users",
    )
    ```

    Create a table from a single column of data:

    table = mo.ui.table(
      data=[
        {'first_name': 'Michael', 'last_name': 'Scott'},
        {'first_name': 'Dwight', 'last_name': 'Schrute'}
      ],
      label='Users'
    )

    Create a table from a dataframe:

    ```python
    # df is a Pandas or Polars dataframe
    table = mo.ui.table(
        data=df,
        # use pagination when your table has many rows
        pagination=True,
        label="Dataframe",
    )
    ```

    Create a table with format mapping:

    ```python
    # format_mapping is a dict keyed by column names,
    # with values as formatting functions or strings
    def format_name(name):
        return name.upper()


    table = mo.ui.table(
        data=[
            {"first_name": "Michael", "last_name": "Scott", "age": 45},
            {"first_name": "Dwight", "last_name": "Schrute", "age": 40},
        ],
        format_mapping={
            "first_name": format_name,  # Use callable to format first names
            "age": "{:.1f}".format,  # Use string format for age
        },
        label="Format Mapping",
    )
    ```
    In each case, access the table data with `table.value`.

    **Attributes.**

    - `value`: the selected rows, in the same format as the original data,
       or `None` if no selection
    - `data`: the original table data

    **Initialization Args.**

    - `data`: Values can be primitives (`str`,
      `int`, `float`, `bool`, or `None`) or marimo elements: e.g.
      `mo.ui.button(...)`, `mo.md(...)`, `mo.as_html(...)`, etc. Data can be
      passed in many ways:
        - as dataframes: a pandas dataframe, a polars dataframe
        - as rows: a list of dicts, where each dict represents a row in the
          table
        - as columns: a dict keyed by column names, where the value of each
          entry is a list representing a column
        - as a single column: a list of values
    - `pagination`: whether to paginate; if `False`, all rows will be shown
      defaults to `True` when above 10 rows, `False` otherwise
    - `selection`: 'single' or 'multi' to enable row selection, or `None` to
        disable
    - `page_size`: the number of rows to show per page.
      defaults to 10
    - `show_column_summaries`: whether to show column summaries
      defaults to `True` when the table has less than 40 columns, `False` otherwise
    - `show_download`: whether to show the download button
      defaults to `True` for dataframes, `False` otherwise
    - `format_mapping`: a mapping from column names to formatting strings
    or functions
    - `freeze_columns_left`: list of column names to freeze on the left
    - `freeze_columns_right`: list of column names to freeze on the right
    - `text_justify_columns`: dictionary of column names to text justification
      options: `left`, `center`, `right`
    - `wrapped_columns`: list of column names to wrap
    - `label`: markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    - `max_columns`: maximum number of columns to display, defaults to 50.
      Set to None to show all columns.
    """
    _name: Final[str] = ...
    def __init__(self, data: Union[ListOrTuple[Union[str, int, float, bool, MIME, None]], ListOrTuple[Dict[str, JSONType]], Dict[str, ListOrTuple[JSONType]], IntoDataFrame,], pagination: Optional[bool] = ..., selection: Optional[Literal["single", "multi"]] = ..., page_size: int = ..., show_column_summaries: Optional[bool] = ..., format_mapping: Optional[Dict[str, Union[str, Callable[..., Any]]]] = ..., freeze_columns_left: Optional[Sequence[str]] = ..., freeze_columns_right: Optional[Sequence[str]] = ..., text_justify_columns: Optional[Dict[str, Literal["left", "center", "right"]]] = ..., wrapped_columns: Optional[List[str]] = ..., show_download: bool = ..., max_columns: Optional[int] = ..., *, label: str = ..., on_change: Optional[Callable[[Union[List[JSONType], Dict[str, ListOrTuple[JSONType]], IntoDataFrame,]], None,]] = ..., _internal_column_charts_row_limit: Optional[int] = ..., _internal_summary_row_limit: Optional[int] = ..., _internal_total_rows: Optional[Union[int, Literal["too_many"]]] = ...) -> None:
        ...
    
    @property
    def data(self) -> TableData:
        ...
    
    def download_as(self, args: DownloadAsArgs) -> str:
        ...
    
    def get_column_summaries(self, args: EmptyArgs) -> ColumnSummaries:
        ...
    
    def search(self, args: SearchTableArgs) -> SearchTableResponse:
        ...
    
    def __hash__(self) -> int:
        ...
    


