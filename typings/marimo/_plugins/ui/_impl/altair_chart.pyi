"""
This type stub file was generated by pyright.
"""

import altair
from typing import Any, Callable, Dict, Final, List, Literal, Optional, TYPE_CHECKING, Union
from narwhals.typing import IntoDataFrame
from marimo._output.rich_help import mddoc
from marimo._plugins.ui._core.ui_element import UIElement

"""
This type stub file was generated by pyright.
"""
LOGGER = ...
if TYPE_CHECKING:
    ...
ChartSelectionField = Dict[str, Union[List[int], List[float], List[str]]]
ChartSelection = Dict[str, ChartSelectionField]
VegaSpec = Dict[str, Any]
RowOrientedData = List[Dict[str, Any]]
ColumnOrientedData = Dict[str, List[Any]]
ChartDataType = Union[IntoDataFrame, RowOrientedData, ColumnOrientedData]
@mddoc
class altair_chart(UIElement[ChartSelection, ChartDataType]):
    """Make reactive charts with Altair

    Use `mo.ui.altair_chart` to make Altair charts reactive: select chart data
    with your cursor on the frontend, get them as a dataframe in Python!

    Supports polars, pandas, and arrow DataFrames.

    **Example.**

    ```python
    import altair as alt
    import marimo as mo
    from vega_datasets import data

    chart = (
        alt.Chart(data.cars())
        .mark_point()
        .encode(
            x="Horsepower",
            y="Miles_per_Gallon",
            color="Origin",
        )
    )

    chart = mo.ui.altair_chart(chart)
    ```

    ```
    # View the chart and selected data as a dataframe
    mo.hstack([chart, chart.value])
    ```

    **Attributes.**

    - `value`: a dataframe of the plot data filtered by the selections
    - `dataframe`: a dataframe of the unfiltered chart data
    - `selections`: the selection of the chart; this may be an interval along
       the name of an axis or a selection of points

    **Initialization Args.**

    - `chart`: An `altair.Chart`
    - `chart_selection`: optional selection type,
        `"point"`, `"interval"`, or a bool; defaults to `True` which will
        automatically detect the best selection type.
        This is ignored if the chart already has a point/interval selection param.
    - `legend_selection`: optional list of legend fields (columns) for which to
        enable selection, `True` to enable selection for all fields, or
        `False` to disable selection entirely.
        This is ignored if the chart already has a legend selection param.
    - `label`: optional markdown label for the element
    - `on_change`: optional callback to run when this element's value changes
    """
    name: Final[str] = ...
    def __init__(self, chart: altair.Chart, chart_selection: Literal["point"] | Literal["interval"] | bool = ..., legend_selection: list[str] | bool = ..., *, label: str = ..., on_change: Optional[Callable[[ChartDataType], None]] = ...) -> None:
        ...
    
    @property
    def selections(self) -> ChartSelection:
        ...
    
    def apply_selection(self, df: ChartDataType) -> ChartDataType:
        """Apply the selection to a DataFrame.

        This method is useful when you have a layered chart and you want to
        apply the selection to a DataFrame.

        **Example.**

        ```python
        import altair as alt
        import marimo as mo
        from vega_datasets import data

        cars = data.cars()

        _chart = (
            alt.Chart(cars)
            .mark_point()
            .encode(
                x="Horsepower",
                y="Miles_per_Gallon",
                color="Origin",
            )
        )

        chart = mo.ui.altair_chart(_chart)
        chart

        # In another cell
        selected_df = chart.apply_selection(cars)
        ```

        **Args.**

        - `df`: a DataFrame to apply the selection to

        **Returns.**

        - a DataFrame of the plot data filtered by the selections
        """
        ...
    
    def __getattr__(self, name: str) -> Any:
        ...
    
    def __add__(self, other: Any) -> Any:
        ...
    
    def __or__(self, value: Any) -> Any:
        ...
    
    def __radd__(self, other: Any) -> Any:
        ...
    
    def __ror__(self, value: Any) -> Any:
        ...
    
    def __and__(self, value: Any) -> Any:
        ...
    
    @property
    def value(self) -> ChartDataType:
        ...
    
    @value.setter
    def value(self, value: ChartDataType) -> None:
        ...
    


def maybe_make_full_width(chart: altair.Chart) -> altair.Chart:
    ...

