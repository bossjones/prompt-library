"""
This type stub file was generated by pyright.
"""

import abc
from dataclasses import dataclass
from typing import Any, Callable, Dict, Generic, Optional, Sequence, TYPE_CHECKING, TypeVar
from marimo._output.hypertext import Html
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._runtime.functions import Function
from marimo._plugins.ui._impl.input import form as form_plugin

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
S = TypeVar("S", bound=JSONType)
T = TypeVar("T")
LOGGER = ...
@dataclass
class Lens:
    """Track how a view of a higher-order element relates to its source

    Higher-order UI elements support lensing, ie extracting their children
    as "views". These views can be embedded in other outputs and interacted
    with.

    UI elements that are views of a higher-order element (eg, an entry of
    an array is a view of the array) have a lens object that stores the
    id of its parent UI element, and the key at which its parent stores it.
    """
    parent_id: str
    key: str
    ...


@dataclass
class InitializationArgs(Generic[S, T]):
    component_name: str
    initial_value: S
    label: Optional[str]
    on_change: Optional[Callable[[T], None]]
    args: dict[str, JSONType]
    slotted_html: str
    functions: tuple[Function[Any, Any], ...]
    ...


class MarimoConvertValueException(Exception):
    ...


@mddoc
class UIElement(Html, Generic[S, T], metaclass=abc.ABCMeta):
    """An HTML element with a value

    A `UIElement` is an HTML element with a value; when the value of the
    element on the page changes, the value of the UIElement is updated as well.

    This is an abstract class. `UIElement`s are responsible for mapping values
    sent by the frontend (of type S) to values expected by the Python object
    (of type T): a subclass can be made concrete by implementing the
    `_convert_value` method.

    Type Parameters:

    - S: The type of the values sent by the frontend to the kernel; must be
         JSON-serializable
    - T: The type of the UIElement's value; can be any type

    **Attributes.**

    - value: The value of the `UIElement`.

    **Methods.**

    - form: create a submittable form this `UIElement`.
    """
    _value_frontend: S
    _value: T
    _random_seed = ...
    def __init__(self, component_name: str, initial_value: S, label: Optional[str], on_change: Optional[Callable[[T], None]], args: dict[str, JSONType], slotted_html: str = ..., functions: tuple[Function[Any, Any], ...] = ...) -> None:
        """Initialize a UIElement

        Args:
        ----
        component_name: tag name of the custom element
        initial_value: initial value of the element in the frontend
        label: markdown string, label of element
        on_change: callback, called with element's new value on change
        args: arguments that the element takes
        slotted_html: any html to slot in the custom element
        functions: any functions to register with the graph
        """
        ...
    
    @property
    def value(self) -> T:
        """The element's current value."""
        ...
    
    @value.setter
    def value(self, value: T) -> None:
        ...
    
    def __setattr__(self, name: str, value: Any) -> None:
        ...
    
    @mddoc
    def form(self, label: str = ..., *, bordered: bool = ..., loading: bool = ..., submit_button_label: str = ..., submit_button_tooltip: Optional[str] = ..., submit_button_disabled: bool = ..., clear_on_submit: bool = ..., show_clear_button: bool = ..., clear_button_label: str = ..., clear_button_tooltip: Optional[str] = ..., validate: Optional[Callable[[Optional[JSONType]], Optional[str]]] = ..., on_change: Optional[Callable[[Optional[T]], None]] = ...) -> form_plugin[S, T]:
        """Create a submittable form out of this `UIElement`.

        Use this method to create a form that gates the submission
        of a `UIElement`s value until a submit button is clicked.

        The value of the `form` is the value of the underlying
        element the last time the form was submitted.

        **Examples.**

        Convert any `UIElement` into a form:

        ```python
        prompt = mo.ui.text_area().form()
        ```

        Combine with `HTML.batch` to create a form made out of multiple
        `UIElements`:

        ```python
        form = (
            mo.ui.md(
                '''
            **Enter your prompt.**

            {prompt}

            **Choose a random seed.**

            {seed}
            '''
            )
            .batch(
                prompt=mo.ui.text_area(),
                seed=mo.ui.number(),
            )
            .form()
        )
        ```

        **Args.**

        - `label`: A text label for the form.
        - `bordered`: whether the form should have a border
        - `loading`: whether the form should be in a loading state
        - `submit_button_label`: the label of the submit button
        - `submit_button_tooltip`: the tooltip of the submit button
        - `submit_button_disabled`: whether the submit button should be
          disabled
        - `clear_on_submit`: whether the form should clear its contents after
            submitting
        - `show_clear_button`: whether the form should show a clear button
        - `clear_button_label`: the label of the clear button
        - `clear_button_tooltip`: the tooltip of the clear button
        - `validate`: a function that takes the form's value and returns an
            error message if the value is invalid,
            or `None` if the value is valid
        """
        ...
    
    def send_message(self, message: Dict[str, object], buffers: Optional[Sequence[bytes]]) -> None:
        """
        Send a message to the element rendered on the frontend
        from the backend.
        """
        ...
    
    def __deepcopy__(self, memo: dict[int, Any]) -> UIElement[S, T]:
        ...
    
    def __bool__(self) -> bool:
        ...
    


