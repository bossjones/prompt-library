"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, ClassVar, Dict, List, Literal, Optional, Sequence, Tuple, Union
from marimo._ast.app import _AppConfig
from marimo._ast.cell import CellConfig, CellId_t, RuntimeStateType
from marimo._data.models import ColumnSummary, DataTable, DataTableSource
from marimo._messaging.cell_output import CellChannel, CellOutput
from marimo._messaging.completion_option import CompletionOption
from marimo._messaging.errors import Error
from marimo._messaging.mimetypes import KnownMimeType
from marimo._messaging.types import Stream
from marimo._plugins.core.web_component import JSONType
from marimo._runtime.layout.layout import LayoutConfig

"""Message Types

Messages that the kernel sends to the frontend.
"""
LOGGER = ...
def serialize(datacls: Any) -> Dict[str, JSONType]:
    ...

@dataclass
class Op:
    name: ClassVar[str]
    def broadcast(self, stream: Optional[Stream] = ...) -> None:
        ...

    def serialize(self) -> dict[str, Any]:
        ...



@dataclass
class CellOp(Op):
    """Op to transition a cell.

    A CellOp's data has three optional fields:

    output       - a CellOutput
    console      - a CellOutput (console msg to append), or a list of
                   CellOutputs
    status       - execution status
    stale_inputs - whether the cell has stale inputs (variables, modules, ...)

    Omitting a field means that its value should be unchanged!

    And one required field:

    cell_id - the cell id
    """
    name: ClassVar[str] = ...
    cell_id: CellId_t
    output: Optional[CellOutput] = ...
    console: Optional[Union[CellOutput, List[CellOutput]]] = ...
    status: Optional[RuntimeStateType] = ...
    stale_inputs: Optional[bool] = ...
    timestamp: float = ...
    @staticmethod
    def maybe_truncate_output(mimetype: KnownMimeType, data: str) -> tuple[KnownMimeType, str]:
        ...

    @staticmethod
    def broadcast_output(channel: CellChannel, mimetype: KnownMimeType, data: str, cell_id: Optional[CellId_t], status: Optional[RuntimeStateType], stream: Stream | None = ...) -> None:
        ...

    @staticmethod
    def broadcast_empty_output(cell_id: Optional[CellId_t], status: Optional[RuntimeStateType], stream: Stream | None = ...) -> None:
        ...

    @staticmethod
    def broadcast_console_output(channel: CellChannel, mimetype: KnownMimeType, data: str, cell_id: Optional[CellId_t], status: Optional[RuntimeStateType], stream: Stream | None = ...) -> None:
        ...

    @staticmethod
    def broadcast_status(cell_id: CellId_t, status: RuntimeStateType, stream: Stream | None = ...) -> None:
        ...

    @staticmethod
    def broadcast_error(data: Sequence[Error], clear_console: bool, cell_id: CellId_t) -> None:
        ...

    @staticmethod
    def broadcast_stale(cell_id: CellId_t, stale: bool, stream: Stream | None = ...) -> None:
        ...



@dataclass
class HumanReadableStatus:
    """Human-readable status."""
    code: Literal["ok", "error"]
    title: Union[str, None] = ...
    message: Union[str, None] = ...


@dataclass
class FunctionCallResult(Op):
    """Result of calling a function."""
    name: ClassVar[str] = ...
    function_call_id: str
    return_value: JSONType
    status: HumanReadableStatus
    def __post_init__(self) -> None:
        ...

    def serialize(self) -> dict[str, Any]:
        ...



@dataclass
class RemoveUIElements(Op):
    """Invalidate UI elements for a given cell."""
    name: ClassVar[str] = ...
    cell_id: CellId_t


@dataclass
class SendUIElementMessage(Op):
    """Send a message to a UI element."""
    name: ClassVar[str] = ...
    ui_element: str
    message: Dict[str, object]
    buffers: Optional[Sequence[str]]


@dataclass
class Interrupted(Op):
    """Written when the kernel is interrupted by the user."""
    name: ClassVar[str] = ...


@dataclass
class CompletedRun(Op):
    """Written on run completion (of submitted cells and their descendants."""
    name: ClassVar[str] = ...


@dataclass
class KernelCapabilities:
    sql: bool = ...
    terminal: bool = ...
    def __post_init__(self) -> None:
        ...



@dataclass
class KernelReady(Op):
    """Kernel is ready for execution."""
    name: ClassVar[str] = ...
    cell_ids: Tuple[CellId_t, ...]
    codes: Tuple[str, ...]
    names: Tuple[str, ...]
    layout: Optional[LayoutConfig]
    configs: Tuple[CellConfig, ...]
    resumed: bool
    ui_values: Optional[Dict[str, JSONType]]
    last_executed_code: Optional[Dict[CellId_t, str]]
    last_execution_time: Optional[Dict[CellId_t, float]]
    app_config: _AppConfig
    kiosk: bool
    capabilities: KernelCapabilities


@dataclass
class CompletionResult(Op):
    """Code completion result."""
    name: ClassVar[str] = ...
    completion_id: str
    prefix_length: int
    options: List[CompletionOption]


@dataclass
class Alert(Op):
    name: ClassVar[str] = ...
    title: str
    description: str
    variant: Optional[Literal["danger"]] = ...


@dataclass
class MissingPackageAlert(Op):
    name: ClassVar[str] = ...
    packages: List[str]
    isolated: bool


PackageStatusType = Dict[str, Literal["queued", "installing", "installed", "failed"]]
@dataclass
class InstallingPackageAlert(Op):
    name: ClassVar[str] = ...
    packages: PackageStatusType


@dataclass
class Reconnected(Op):
    name: ClassVar[str] = ...


@dataclass
class Banner(Op):
    name: ClassVar[str] = ...
    title: str
    description: str
    variant: Optional[Literal["danger"]] = ...
    action: Optional[Literal["restart"]] = ...


@dataclass
class Reload(Op):
    name: ClassVar[str] = ...


@dataclass
class VariableDeclaration:
    name: str
    declared_by: List[CellId_t]
    used_by: List[CellId_t]
    ...


@dataclass
class VariableValue:
    name: str
    value: Optional[str]
    datatype: Optional[str]
    def __init__(self, name: str, value: object, datatype: Optional[str] = ...) -> None:
        ...



@dataclass
class Variables(Op):
    """List of variable declarations."""
    name: ClassVar[str] = ...
    variables: List[VariableDeclaration]


@dataclass
class VariableValues(Op):
    """List of variables and their types/values."""
    name: ClassVar[str] = ...
    variables: List[VariableValue]


@dataclass
class Datasets(Op):
    """List of datasets."""
    name: ClassVar[str] = ...
    tables: List[DataTable]
    clear_channel: Optional[DataTableSource] = ...


@dataclass
class DataColumnPreview(Op):
    """Preview of a column in a dataset."""
    name: ClassVar[str] = ...
    table_name: str
    column_name: str
    chart_spec: Optional[str] = ...
    chart_max_rows_errors: bool = ...
    chart_code: Optional[str] = ...
    error: Optional[str] = ...
    summary: Optional[ColumnSummary] = ...


@dataclass
class QueryParamsSet(Op):
    """Set query parameters."""
    name: ClassVar[str] = ...
    key: str
    value: Union[str, List[str]]


@dataclass
class QueryParamsAppend(Op):
    name: ClassVar[str] = ...
    key: str
    value: str


@dataclass
class QueryParamsDelete(Op):
    name: ClassVar[str] = ...
    key: str
    value: Optional[str]


@dataclass
class QueryParamsClear(Op):
    name: ClassVar[str] = ...


@dataclass
class FocusCell(Op):
    name: ClassVar[str] = ...
    cell_id: CellId_t


@dataclass
class UpdateCellCodes(Op):
    name: ClassVar[str] = ...
    cell_ids: List[CellId_t]
    codes: List[str]


@dataclass
class UpdateCellIdsRequest(Op):
    """
    Update the cell ID ordering of the cells in the notebook.

    Right now we send the entire list of cell IDs,
    but in the future we might want to send change-deltas.
    """
    name: ClassVar[str] = ...
    cell_ids: List[CellId_t]


MessageOperation = Union[CellOp, FunctionCallResult, SendUIElementMessage, RemoveUIElements, Reload, Reconnected, Interrupted, CompletedRun, KernelReady, CompletionResult, Alert, Banner, MissingPackageAlert, InstallingPackageAlert, Variables, VariableValues, QueryParamsSet, QueryParamsAppend, QueryParamsDelete, QueryParamsClear, Datasets, DataColumnPreview, FocusCell, UpdateCellCodes, UpdateCellIdsRequest,]
