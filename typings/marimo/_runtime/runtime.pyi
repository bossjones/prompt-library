"""
This type stub file was generated by pyright.
"""

import contextlib
import dataclasses
import pathlib
import queue
from typing import Any, Callable, Iterator, Optional, TYPE_CHECKING
from marimo._ast.cell import CellConfig, CellId_t
from marimo._config.config import MarimoConfig
from marimo._messaging.ops import HumanReadableStatus
from marimo._messaging.types import KernelMessage, Stderr, Stdin, Stdout, Stream
from marimo._output.rich_help import mddoc
from marimo._plugins.core.web_component import JSONType
from marimo._runtime import marimo_pdb
from marimo._runtime.app_meta import AppMeta
from marimo._runtime.params import CLIArgs, QueryParams
from marimo._runtime.requests import AppMetadata, CodeCompletionRequest, ControlRequest, CreationRequest, DeleteCellRequest, ExecutionRequest, FunctionCallRequest, InstallMissingPackagesRequest, PreviewDatasetColumnRequest, SetCellConfigRequest, SetUIElementValueRequest, SetUserConfigRequest
from marimo._runtime.runner.hooks_on_finish import OnFinishHookType
from marimo._runtime.runner.hooks_post_execution import PostExecutionHookType
from marimo._runtime.runner.hooks_pre_execution import PreExecutionHookType
from marimo._runtime.runner.hooks_preparation import PreparationHookType
from marimo._runtime.state import State
from marimo._server.types import QueueType
from marimo._tracer import kernel_tracer
from collections.abc import Sequence
from types import ModuleType

if TYPE_CHECKING:
    ...
LOGGER = ...
@mddoc
def defs() -> tuple[str, ...]:
    """Get the definitions of the currently executing cell.

    **Returns**:

    - tuple of the currently executing cell's defs.
    """
    ...

@mddoc
def refs() -> tuple[str, ...]:
    """Get the references of the currently executing cell.

    **Returns**:

    - tuple of the currently executing cell's refs.
    """
    ...

@mddoc
def query_params() -> QueryParams:
    """Get the query parameters of a marimo app.

    **Examples**:

    Keep the text input in sync with the URL query parameters.

    ```python3
    # In it's own cell
    query_params = mo.query_params()

    # In another cell
    search = mo.ui.text(
        value=query_params["search"] or "",
        on_change=lambda value: query_params.set("search", value),
    )
    search
    ```

    You can also set the query parameters reactively:

    ```python3
    toggle = mo.ui.switch(label="Toggle me")
    toggle

    # In another cell
    query_params["is_enabled"] = toggle.value
    ```

    **Returns**:

    - A `QueryParams` object containing the query parameters.
      You can directly interact with this object like a dictionary.
      If you mutate this object, changes will be persisted to the frontend
      query parameters and any other cells referencing the query parameters
      will automatically re-run.
    """
    ...

@mddoc
def app_meta() -> AppMeta:
    """Get the metadata of a marimo app.

    The `AppMeta` class provides access to runtime metadata about a marimo app,
    such as its display theme and execution mode.

    **Examples**:

    Get the current theme and conditionally set a plotting library's theme:

    ```python
    import altair as alt

    # Enable dark theme for Altair when marimo is in dark mode
    alt.themes.enable("dark" if mo.app_meta().theme == "dark" else "default")
    ```

    Show content only in edit mode:

    ```python
    # Only show this content when editing the notebook
    mo.md("# Developer Notes") if mo.app_meta().mode == "edit" else None
    ```

    **Returns**:

    - An `AppMeta` object containing the app's metadata.
    """
    ...

@mddoc
def cli_args() -> CLIArgs:
    """Get the command line arguments of a marimo notebook.

        **Examples**:

    `marimo edit notebook.py -- -size 10`

        ```python3
        # Access the command line arguments
        size = mo.cli_args().get("size") or 100

        for i in range(size):
            print(i)
        ```

        **Returns**:

        - A dictionary containing the command line arguments.
          This dictionary is read-only and cannot be mutated.
    """
    ...

@mddoc
def notebook_dir() -> pathlib.Path | None:
    """Get the directory of the currently executing notebook.

    **Returns**:

    - A `pathlib.Path` object representing the directory of the current
      notebook, or `None` if the notebook's directory cannot be determined.

    **Examples**:

    ```python
    data_file = mo.notebook_dir() / "data" / "example.csv"
    # Use the directory to read a file
    if data_file.exists():
        print(f"Found data file: {data_file}")
    else:
        print("No data file found")
    ```
    """
    ...

@dataclasses.dataclass
class CellMetadata:
    """CellMetadata

    Metadata the kernel needs to persist, even when a cell is removed
    from the graph or when a cell can't be formed from user code due to syntax
    errors.
    """
    config: CellConfig = ...


class Kernel:
    """Kernel that manages the dependency graph and its execution.

    Args:
    - cell_configs: initial configuration for each cell
    - app_metadata: metadata about the notebook
    - user_config: the initial user configuration
    - stream: object used to communicate with the server/outside world
    - stdout: replacement for sys.stdout
    - stderr: replacement for sys.stderr
    - stdin: replacement for sys.stdin
    - module: module in which to execute code
    - enqueue_control_request: callback to enqueue control requests
    - debugger_override: a replacement for the built-in Pdb
    """
    def __init__(self, cell_configs: dict[CellId_t, CellConfig], app_metadata: AppMetadata, user_config: MarimoConfig, stream: Stream, stdout: Stdout | None, stderr: Stderr | None, stdin: Stdin | None, module: ModuleType, enqueue_control_request: Callable[[ControlRequest], None], preparation_hooks: list[PreparationHookType] | None = ..., pre_execution_hooks: list[PreExecutionHookType] | None = ..., post_execution_hooks: list[PostExecutionHookType] | None = ..., on_finish_hooks: list[OnFinishHookType] | None = ..., debugger_override: marimo_pdb.MarimoPdb | None = ...) -> None:
        ...

    def lazy(self) -> bool:
        ...

    @property
    def globals(self) -> dict[Any, Any]:
        ...

    @contextlib.contextmanager
    def lock_globals(self) -> Iterator[None]:
        ...

    def start_completion_worker(self, completion_queue: QueueType[CodeCompletionRequest]) -> None:
        """Must be called after context is initialized"""
        ...

    @kernel_tracer.start_as_current_span("code_completion")
    def code_completion(self, request: CodeCompletionRequest, docstrings_limit: int) -> None:
        ...

    def mutate_graph(self, execution_requests: Sequence[ExecutionRequest], deletion_requests: Sequence[DeleteCellRequest]) -> set[CellId_t]:
        """Add and remove cells to/from the graph.

        This method adds the cells in `execution_requests` to the kernel's
        graph (deleting old versions of these cells, if any), and removes the
        cells in `deletion_requests` from the kernel's graph.

        The mutations that this method makes to the graph renders the
        kernel inconsistent (stale).

        This method does not register errors for cells that were previously
        valid and are not descendants of any of the newly registered cells.
        This is important for multiple definition errors, since a user may
        absent-mindedly redefine an existing name when creating a new cell:
        such a mistake shouldn't invalidate the program state.

        Returns
        - set of cells that must be run to return kernel to consistent state
        """
        ...

    def register_state_update(self, state: State[Any]) -> None:
        """Register a state object as having been updated.

        Should be called when a state's setter is called.
        """
        ...

    @kernel_tracer.start_as_current_span("delete_cell")
    async def delete_cell(self, request: DeleteCellRequest) -> None:
        """Delete a cell from kernel and graph."""
        ...

    @kernel_tracer.start_as_current_span("run")
    async def run(self, execution_requests: Sequence[ExecutionRequest]) -> None:
        """Run cells and their descendants.


        The cells may be cells already existing in the graph or new cells.
        Adds the cells in `execution_requests` to the graph before running
        them.

        Cells may use top-level await, which is why this function is async.
        """
        ...

    @kernel_tracer.start_as_current_span("rename_file")
    async def rename_file(self, filename: str) -> None:
        ...

    @kernel_tracer.start_as_current_span("run_scratchpad")
    async def run_scratchpad(self, code: str) -> None:
        ...

    @kernel_tracer.start_as_current_span("run_stale_cells")
    async def run_stale_cells(self) -> None:
        ...

    @kernel_tracer.start_as_current_span("set_cell_config")
    async def set_cell_config(self, request: SetCellConfigRequest) -> None:
        """Update cell configs.

        Cells that are enabled (via config) but stale are run as a side-effect.
        """
        ...

    @kernel_tracer.start_as_current_span("set_user_config")
    def set_user_config(self, request: SetUserConfigRequest) -> None:
        ...

    @kernel_tracer.start_as_current_span("set_ui_element_value")
    async def set_ui_element_value(self, request: SetUIElementValueRequest) -> bool:
        """Set the value of a UI element bound to a global variable.

        Runs cells that reference the UI element by name.

        Returns True if any ui elements were set, False otherwise
        """
        ...

    def get_ui_initial_value(self, object_id: str) -> Any:
        """Get an initial value for a UIElement, if any

        Initial values are optionally populated during instantiation

        Args:
        ----
        object_id: ID of UIElement

        Returns:
        -------
        initial value of UI element, if any

        Raises:
        ------
        KeyError if object_id not found
        """
        ...

    def reset_ui_initializers(self) -> None:
        ...

    @kernel_tracer.start_as_current_span("function_call_request")
    async def function_call_request(self, request: FunctionCallRequest) -> tuple[HumanReadableStatus, JSONType, bool]:
        """Execute a function call.

        If the function is not found, children contexts are also searched.
        Returns a status, payload, and a bool which is True if the function was
        found, False otherwise.
        """
        ...

    @kernel_tracer.start_as_current_span("instantiate")
    async def instantiate(self, request: CreationRequest) -> None:
        """Instantiate the kernel with cells and UIElement initial values

        During instantiation, UIElements can check for an initial value
        with `get_initial_value`
        """
        ...

    async def install_missing_packages(self, request: InstallMissingPackagesRequest) -> None:
        """Attempts to install packages for modules that cannot be imported

        Runs cells affected by successful installation.
        """
        ...

    @kernel_tracer.start_as_current_span("preview_dataset_column")
    async def preview_dataset_column(self, request: PreviewDatasetColumnRequest) -> None:
        """Preview a column of a dataset.

        The dataset is loaded, and the column is displayed in the frontend.
        """
        ...

    async def handle_message(self, request: ControlRequest) -> None:
        """Handle a message from the client.

        The message is dispatched to the appropriate method based on its type.

        Coarsely locks globals to avoid race conditions with code completion.
        """
        ...



def launch_kernel(control_queue: QueueType[ControlRequest], set_ui_element_queue: QueueType[SetUIElementValueRequest], completion_queue: QueueType[CodeCompletionRequest], input_queue: QueueType[str], stream_queue: queue.Queue[KernelMessage] | None, socket_addr: tuple[str, int] | None, is_edit_mode: bool, configs: dict[CellId_t, CellConfig], app_metadata: AppMetadata, user_config: MarimoConfig, virtual_files_supported: bool, redirect_console_to_browser: bool, interrupt_queue: QueueType[bool] | None = ..., profile_path: Optional[str] = ..., log_level: int | None = ...) -> None:
    ...
