"""
This type stub file was generated by pyright.
"""

import weakref
from typing import Callable, Generic, Type, TypeVar, Union

T = TypeVar("T")
Ref = Union[weakref.ReferenceType[T], Callable[[], T]]
class CloneError(Exception):
    """Thrown when strict execution fail to deep copy or clone."""
    ...


class ReadOnlyError(Exception):
    """Thrown when attempting to modify a read-only object."""
    ...


class _Copy(Generic[T]):
    """Base wrapper class for strict execution."""
    __ref__: Ref[T]
    ...


class ZeroCopy(_Copy[T]):
    """Wrapper class for strict execution (stops deepcopy)."""
    ...


class ShallowCopy(_Copy[T]):
    """Wrapper class for strict execution (does copy over deepcopy)."""
    ...


def shadow_wrap(ref_cls: Type[_Copy[T]], base: T) -> T:
    """
    Wraps the base object by copying all attributes over to slots, and the then
    restricting write access to the object attributes / items directly. This is
    very agrressive and makes the wrapped object difficult to tell apart from
    the base object without inspect.

    However, there are some limitations, e.g. some operations of the wrapped
    object may not be associative if they are not defined for both the left
    and right operations. For instance:

    >>> a = shadow_wrap(ZeroCopy, [1, 2, 3])
    >>> b = [4, 5, 6]
    >>> a + b
    [1, 2, 3, 4, 5, 6]

    will work, but:

    >>> b + a

    will not work, as the `__add__` method is not defined for custom objects in
    the right operand. However, The original wrapped object can still be
    accessed with unwrap_copy(). The internal class is named as a hint for this
    reason, although most times this will be invisible.
    """
    class ReadOnly_try_marimo_unwrap_copy(ref_cls):
        ...



def unwrap_copy(base: T) -> T:
    """
    Given a ZeroCopy or ShallowCopy object, returns the original object.
    """
    ...

def zero_copy(base: T) -> T:
    """
    Wraps object in a ZeroCopy wrapper to mark the object for no copying /
    cloning when running in strict execution mode.
    """
    ...

def shallow_copy(base: T) -> T:
    """
    Wraps object in a ShallowCopy wrapper to mark the object for "copy" over
    "deepcopy" when running in strict execution mode.
    """
    ...
