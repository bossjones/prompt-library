"""
This type stub file was generated by pyright.
"""

import threading
from dataclasses import dataclass
from typing import Any, Callable, List, Literal, Optional, TYPE_CHECKING, Tuple
from marimo._ast.cell import CellId_t, CellImpl
from marimo._ast.visitor import ImportData, Name, VariableData
from collections.abc import Collection

if TYPE_CHECKING:
    ...
Edge = Tuple[CellId_t, CellId_t]
EdgeWithVar = Tuple[CellId_t, List[str], CellId_t]
LOGGER = ...
@dataclass(frozen=True)
class DirectedGraph:
    cells: dict[CellId_t, CellImpl] = ...
    children: dict[CellId_t, set[CellId_t]] = ...
    parents: dict[CellId_t, set[CellId_t]] = ...
    siblings: dict[CellId_t, set[CellId_t]] = ...
    definitions: dict[Name, set[CellId_t]] = ...
    cycles: set[tuple[Edge, ...]] = ...
    lock: threading.Lock = ...
    def is_cell_cached(self, cell_id: CellId_t, code: str) -> bool:
        """Whether a cell with id `cell_id` and code `code` is in the graph."""
        ...

    def get_defining_cells(self, name: Name) -> set[CellId_t]:
        """Get all cells that define name.

        This is a singleton for well-formed graphs.
        """
        ...

    def get_referring_cells(self, name: Name, language: Literal["python", "sql"]) -> set[CellId_t]:
        """Get all cells that have a ref to `name`.

        The variable can be either a Python variable or a SQL variable (table).
        """
        ...

    def get_path(self, source: CellId_t, dst: CellId_t) -> list[Edge]:
        """Get a path from `source` to `dst`, if any."""
        ...

    def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:
        """Add a cell to the graph.

        Mutates the graph, acquiring `self.lock`.

        Requires that `cell_id` is not already in the graph.
        """
        ...

    def is_any_ancestor_stale(self, cell_id: CellId_t) -> bool:
        ...

    def is_any_ancestor_disabled(self, cell_id: CellId_t) -> bool:
        ...

    def disable_cell(self, cell_id: CellId_t) -> None:
        """
        Disables a cell in the graph.

        Does not mutate the graph (but does mutate cell statuses).

        Returns the ids of descendants that are disabled transitively.
        """
        ...

    def enable_cell(self, cell_id: CellId_t) -> set[CellId_t]:
        """
        Enables a cell in the graph.

        Does not mutate the graph (but does mutate cell statuses).

        Returns:
        - set of cells that were stale and should be re-run
        """
        ...

    def delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:
        """Removes a cell from the graph.

        Mutates the graph, acquiring `self.lock`.

        Returns the ids of the children of the removed cell.
        """
        ...

    def is_disabled(self, cell_id: CellId_t) -> bool:
        ...

    def get_imports(self, cell_id: Optional[CellId_t] = ...) -> dict[Name, ImportData]:
        ...

    def get_multiply_defined(self) -> list[Name]:
        ...

    def get_deleted_nonlocal_ref(self) -> list[Name]:
        ...

    def descendants(self, cell_id: CellId_t) -> set[CellId_t]:
        ...

    def ancestors(self, cell_id: CellId_t) -> set[CellId_t]:
        ...

    def set_stale(self, cell_ids: set[CellId_t], prune_imports: bool = ...) -> None:
        ...

    def get_stale(self) -> set[CellId_t]:
        ...

    def get_transitive_references(self, refs: set[Name], inclusive: bool = ..., predicate: Callable[[Name, VariableData], bool] | None = ...) -> set[Name]:
        """Return a set of the passed-in cells' references and their
        references on the block (function / class) level.

        If inclusive, includes the references of the passed-in cells in the
        set.

        If predicate, only references satisfying predicate(ref) are included
        """
        ...



def transitive_closure(graph: DirectedGraph, cell_ids: set[CellId_t], children: bool = ..., inclusive: bool = ..., relatives: (Callable[[DirectedGraph, CellId_t, bool], set[CellId_t]] | None) = ..., predicate: Callable[[CellImpl], bool] | None = ...) -> set[CellId_t]:
    """Return a set of the passed-in cells and their descendants or ancestors

    If children is True, returns descendants; otherwise, returns ancestors

    If inclusive, includes passed-in cells in the set.

    If relatives is not None, it computes the parents/children of a
        cell

    If predicate, only cells satisfying predicate(cell) are included; applied
        after the relatives are computed
    """
    ...

def induced_subgraph(graph: DirectedGraph, cell_ids: Collection[CellId_t]) -> tuple[dict[CellId_t, set[CellId_t]], dict[CellId_t, set[CellId_t]]]:
    """Return parents and children for each node in `cell_ids`

    Represents the subgraph induced by `cell_ids`.
    """
    ...

def get_cycles(graph: DirectedGraph, cell_ids: Collection[CellId_t]) -> list[tuple[Edge, ...]]:
    """Get all cycles among `cell_ids`."""
    ...

def topological_sort(graph: DirectedGraph, cell_ids: Collection[CellId_t]) -> list[CellId_t]:
    """Sort `cell_ids` in a topological order using a heap queue.

    When multiple cells have the same parents (including no parents), the tie is broken by
    registration order - cells registered earlier are processed first.
    """
    ...

def import_block_relatives(graph: DirectedGraph, cid: CellId_t, children: bool) -> set[CellId_t]:
    ...

class Runner:
    """Utility for running individual cells in a graph

    This class provides methods to a run a cell in the graph and obtain its
    output (last expression) and the values of its defs.

    If needed, the runner will recursively compute the values of the cell's
    refs by executing its ancestors. Refs can also be substituted by the
    caller.

    TODO(akshayka): Add an API for caching defs across cell runs.
    """
    def __init__(self, graph: DirectedGraph) -> None:
        ...

    def is_coroutine(self, cell_id: CellId_t) -> bool:
        ...

    async def run_cell_async(self, cell_id: CellId_t, kwargs: dict[str, Any]) -> tuple[Any, dict[str, Any]]:
        """Run a possibly async cell and its ancestors

        Substitutes kwargs as refs for the cell, omitting ancestors that
        whose refs are substituted.
        """
        ...

    def run_cell_sync(self, cell_id: CellId_t, kwargs: dict[str, Any]) -> tuple[Any, dict[str, Any]]:
        """Run a synchronous cell and its ancestors

        Substitutes kwargs as refs for the cell, omitting ancestors that
        whose refs are substituted.

        Raises a `RuntimeError` if the cell or any of its unsubstituted
        ancestors are coroutine functions.
        """
        ...
