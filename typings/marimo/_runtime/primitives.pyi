"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Optional, TYPE_CHECKING, Union
from marimo._ast.visitor import Name, VariableData
from marimo._runtime.dataflow import DirectedGraph

if TYPE_CHECKING:
    ...
PRIMITIVES: tuple[type, ...] = ...
CLONE_PRIMITIVES = ...
FN_CACHE_TYPE = Optional[dict[Union[Callable[..., Any], type], bool]]
UNCLONABLE_TYPES = ...
UNCLONABLE_MODULES = ...
def is_external(value: Any) -> bool:
    ...

def is_primitive(value: Any) -> bool:
    ...

def is_primitive_type(value: type) -> bool:
    ...

def is_clone_primitive(value: Any) -> bool:
    ...

def is_data_primitive(value: Any) -> bool:
    ...

def is_data_primitive_container(value: Any) -> bool:
    ...

def is_primitive_container(value: Any) -> bool:
    ...

def is_instance_by_name(obj: object, name: str) -> bool:
    ...

def is_unclonable_type(obj: object) -> bool:
    ...

def from_unclonable_module(obj: object) -> bool:
    ...

def is_pure_scope(ref: Name, defs: dict[str, Any], cache: FN_CACHE_TYPE = ...) -> bool:
    ...

def is_pure_function(ref: Name, value: Any, defs: dict[str, Any], cache: FN_CACHE_TYPE = ..., graph: Optional[DirectedGraph] = ...) -> bool:
    ...

def build_ref_predicate_for_primitives(glbls: dict[str, Any], primitives: Optional[tuple[type, ...]] = ...) -> Callable[[Name, VariableData], bool]:
    """
    Builds a predicate function to determine if a reference should be included

    Args:
        glbls: The global variables dictionary to base the predicate on
        primitives: A tuple of types that should be considered as base types
    Returns:
        A function that takes a variable name and associated data and
        returns True if its reference should be included in a reference search.

    All declared variables are tied together under the graph of required_refs.
    Strict execution gets the minimum graph of definitions for execution.
    Certain definitions, like lambdas, functions, and classes contain an
    executable body and require their `required_refs` to be scope (included in
    this graph). This function determines if a potential reference should be
    included in the graph based on its computed type. Consider:

    >>> def foo():
    ...     return bar()

    here `foo` is a function with `bar` as a reference in the execution body,
    so if `foo` is a reference, both `bar` and `foo` should be included in the
    graph, otherwise we'll get a NameError on `bar` if `foo` is called.
    Compare that to:

    >>> x = foo()

    if `x` is the only reference, should `foo` be included in the graph? It
    depends on the context, so we defer to the type of `x` which has already
    been computed at this point. If `x` is a known 'primitive' type, and thus
    does not have an executable body, we can exclude `foo` from the graph.
    However, `foo` may return a object or another function, which in turn may
    have references; so if x doesn't match the very low bar 'primitive', its
    `required_refs` are included in the graph.

    NB: The builtin `inspect.getclosurevars` exists, but it fails on some of
    these edgecases.

    NB: lambdas, as anonymous functions, do not have a name to refer to them-
    so visitor injects the dummy variable `_lambda` into the `required_refs` to
    denote their presence.
    """
    ...
