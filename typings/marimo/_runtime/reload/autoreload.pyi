"""
This type stub file was generated by pyright.
"""

import types
import weakref
from dataclasses import dataclass
from typing import Any, Callable, Dict, Generic, List, Tuple, Type, TypeVar
from marimo._ast.cell import CellImpl

"""Module reloader

In addition to reloading modules, the reloader also patches instances
of reloaded objects with their code.

Based on the autoreload extension from the IPython project (BSD-3 Clause).
"""
LOGGER = ...
func_attrs = ...
@dataclass
class ModuleMTime:
    name: str
    mtime: float
    ...


OldObjectsMapping = Dict[Tuple[str, str], List[weakref.ref]]
def modules_imported_by_cell(cell: CellImpl, sys_modules: dict[str, types.ModuleType]) -> set[str]:
    """Get the modules imported by a cell"""
    ...

class ModuleDependencyFinder:
    def __init__(self) -> None:
        ...

    def find_dependencies(self, module: types.ModuleType, excludes: list[str]) -> dict[str, types.ModuleType]:
        ...

    def cached(self, module: types.ModuleType) -> bool:
        ...

    def evict_from_cache(self, module: types.ModuleType) -> None:
        ...



class ModuleReloader:
    """Thread-safe module reloader."""
    def __init__(self) -> None:
        ...

    def filename_and_mtime(self, module: types.ModuleType) -> ModuleMTime | None:
        ...

    def cell_uses_stale_modules(self, cell: CellImpl) -> bool:
        ...

    def check(self, modules: dict[str, types.ModuleType], reload: bool) -> set[types.ModuleType]:
        """Check timestamps of modules, optionally reload them.

        Also patches existing objects with hot-reloaded ones.

        Returns a set of modules that were found to have been modified.
        """
        ...

    def get_module_dependencies(self, module: types.ModuleType, excludes: list[str]) -> dict[str, types.ModuleType]:
        ...



def update_function(old: object, new: object) -> None:
    """Upgrade the code object of a function"""
    ...

def update_instances(old: object, new: object) -> None:
    """Use garbage collector to find all instances that refer to the old
    class definition and update their __class__ to point to the new class
    definition"""
    ...

def update_class(old: object, new: object) -> None:
    """Replace stuff in the __dict__ of a class, and upgrade
    method code objects, and add new methods, if any"""
    ...

def update_property(old: object, new: object) -> None:
    """Replace get/set/del functions of a property"""
    ...

def isinstance2(a: object, b: object, typ: Type[Any]) -> bool:
    ...

UPDATE_RULES: list[tuple[Callable[[object, object], bool], Callable[[object, object], None]]] = ...
def update_generic(a: object, b: object) -> bool:
    ...

T = TypeVar("T")
class StrongRef(Generic[T]):
    def __init__(self, obj: T) -> None:
        ...

    def __call__(self) -> T:
        ...



def append_obj(module: types.ModuleType, d: OldObjectsMapping, name: str, obj: object) -> bool:
    ...

def superreload(module: types.ModuleType, old_objects: OldObjectsMapping | None) -> types.ModuleType:
    """Enhanced version of the builtin reload function.

    superreload remembers objects previously in the module, and

    - upgrades the class dictionary of every old class in the module
    - upgrades the code object of every old function and method
    - clears the module's namespace before reloading

    """
    ...
