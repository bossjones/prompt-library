"""
This type stub file was generated by pyright.
"""

import abc
import enum
import importlib
import importlib.machinery
import types
from collections.abc import Iterable, Sequence
from typing import NamedTuple, Protocol

"""
This type stub file was generated by pyright.
"""
class _MetaPathFinder(Protocol):
    def find_spec(self, fullname: str, path: Sequence[str] | None, target: types.ModuleType | None = ...) -> importlib.machinery.ModuleSpec | None:
        ...
    


class ModuleType(enum.Enum):
    """Python module types used for ModuleSpec."""
    C_BUILTIN = ...
    C_EXTENSION = ...
    PKG_DIRECTORY = ...
    PY_CODERESOURCE = ...
    PY_COMPILED = ...
    PY_FROZEN = ...
    PY_RESOURCE = ...
    PY_SOURCE = ...
    PY_ZIPMODULE = ...
    PY_NAMESPACE = ...


_MetaPathFinderModuleTypes: dict[str, ModuleType] = ...
_EditableFinderClasses: set[str] = ...
class ModuleSpec(NamedTuple):
    """Defines a class similar to PEP 420's ModuleSpec.

    A module spec defines a name of a module, its type, location
    and where submodules can be found, if the module is a package.
    """
    name: str
    type: ModuleType | None
    location: str | None = ...
    origin: str | None = ...
    submodule_search_locations: Sequence[str] | None = ...


class Finder:
    """A finder is a class which knows how to find a particular module."""
    def __init__(self, path: Sequence[str] | None = ...) -> None:
        ...
    
    @abc.abstractmethod
    def find_module(self, modname: str, module_parts: Sequence[str], processed: list[str], submodule_path: Sequence[str] | None) -> ModuleSpec | None:
        """Find the given module.

        Each finder is responsible for each protocol of finding, as long as
        they all return a ModuleSpec.

        :param modname: The module which needs to be searched.
        :param module_parts: It should be a list of strings,
                                  where each part contributes to the module's
                                  namespace.
        :param processed: What parts from the module parts were processed
                               so far.
        :param submodule_path: A list of paths where the module
                                    can be looked into.
        :returns: A ModuleSpec, describing how and where the module was found,
                  None, otherwise.
        """
        ...
    
    def contribute_to_path(self, spec: ModuleSpec, processed: list[str]) -> Sequence[str] | None:
        """Get a list of extra paths where this finder can search."""
        ...
    


class ImportlibFinder(Finder):
    """A finder based on the importlib module."""
    _SUFFIXES: Sequence[tuple[str, ModuleType]] = ...
    def find_module(self, modname: str, module_parts: Sequence[str], processed: list[str], submodule_path: Sequence[str] | None) -> ModuleSpec | None:
        ...
    
    def contribute_to_path(self, spec: ModuleSpec, processed: list[str]) -> Sequence[str] | None:
        ...
    


class ExplicitNamespacePackageFinder(ImportlibFinder):
    """A finder for the explicit namespace packages."""
    def find_module(self, modname: str, module_parts: Sequence[str], processed: list[str], submodule_path: Sequence[str] | None) -> ModuleSpec | None:
        ...
    
    def contribute_to_path(self, spec: ModuleSpec, processed: list[str]) -> Sequence[str] | None:
        ...
    


class ZipFinder(Finder):
    """Finder that knows how to find a module inside zip files."""
    def __init__(self, path: Sequence[str]) -> None:
        ...
    
    def find_module(self, modname: str, module_parts: Sequence[str], processed: list[str], submodule_path: Sequence[str] | None) -> ModuleSpec | None:
        ...
    


class PathSpecFinder(Finder):
    """Finder based on importlib.machinery.PathFinder."""
    def find_module(self, modname: str, module_parts: Sequence[str], processed: list[str], submodule_path: Sequence[str] | None) -> ModuleSpec | None:
        ...
    
    def contribute_to_path(self, spec: ModuleSpec, processed: list[str]) -> Sequence[str] | None:
        ...
    


_SPEC_FINDERS = ...
def find_spec(modpath: Iterable[str], path: Iterable[str] | None = ...) -> ModuleSpec:
    """Find a spec for the given module.

    :type modpath: list or tuple
    :param modpath:
      split module's name (i.e name of a module or package split
      on '.'), with leading empty strings for explicit relative import

    :type path: list or None
    :param path:
      optional list of path where the module or package should be
      searched (use sys.path if nothing or None is given)

    :rtype: ModuleSpec
    :return: A module spec, which describes how the module was
             found and where.
    """
    ...

