"""
This type stub file was generated by pyright.
"""

import collections
import collections.abc
from collections.abc import Iterator
from typing import Any, Literal, TYPE_CHECKING
from astroid import decorators, nodes
from astroid.const import PY310_PLUS
from astroid.context import InferenceContext
from astroid.interpreter import objectmodel
from astroid.typing import InferenceErrorInfo, InferenceResult, SuccessfulInferenceResult
from astroid.util import UninferableBase

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
PROPERTIES = ...
if PY310_PLUS:
    ...
POSSIBLE_PROPERTIES = ...
class Proxy:
    """A simple proxy object.

    Note:

    Subclasses of this object will need a custom __getattr__
    if new instance attributes are created. See the Const class
    """
    _proxied: nodes.ClassDef | nodes.FunctionDef | nodes.Lambda | UnboundMethod
    def __init__(self, proxied: (nodes.ClassDef | nodes.FunctionDef | nodes.Lambda | UnboundMethod | None) = ...) -> None:
        ...
    
    def __getattr__(self, name: str) -> Any:
        ...
    
    def infer(self, context: InferenceContext | None = ..., **kwargs: Any) -> collections.abc.Generator[InferenceResult, None, InferenceErrorInfo | None]:
        ...
    


class BaseInstance(Proxy):
    """An instance base class, which provides lookup methods for potential
    instances.
    """
    _proxied: nodes.ClassDef
    special_attributes: objectmodel.ObjectModel
    def display_type(self) -> str:
        ...
    
    def getattr(self, name: str, context: InferenceContext | None = ..., lookupclass: bool = ...) -> list[InferenceResult]:
        ...
    
    def igetattr(self, name: str, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """Inferred getattr."""
        ...
    
    def infer_call_result(self, caller: SuccessfulInferenceResult | None, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """Infer what a class instance is returning when called."""
        ...
    


class Instance(BaseInstance):
    """A special node representing a class instance."""
    special_attributes = ...
    def __init__(self, proxied: nodes.ClassDef | None) -> None:
        ...
    
    @decorators.yes_if_nothing_inferred
    def infer_binary_op(self, opnode: nodes.AugAssign | nodes.BinOp, operator: str, other: InferenceResult, context: InferenceContext, method: SuccessfulInferenceResult) -> Generator[InferenceResult]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def callable(self) -> bool:
        ...
    
    def pytype(self) -> str:
        ...
    
    def display_type(self) -> str:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> bool | UninferableBase:
        """Infer the truth value for an Instance.

        The truth value of an instance is determined by these conditions:

           * if it implements __bool__ on Python 3 or __nonzero__
             on Python 2, then its bool value will be determined by
             calling this special method and checking its result.
           * when this method is not defined, __len__() is called, if it
             is defined, and the object is considered true if its result is
             nonzero. If a class defines neither __len__() nor __bool__(),
             all its instances are considered true.
        """
        ...
    
    def getitem(self, index: nodes.Const, context: InferenceContext | None = ...) -> InferenceResult | None:
        ...
    


class UnboundMethod(Proxy):
    """A special node representing a method not bound to an instance."""
    _proxied: nodes.FunctionDef | UnboundMethod
    special_attributes: (objectmodel.BoundMethodModel | objectmodel.UnboundMethodModel) = ...
    def __repr__(self) -> str:
        ...
    
    def implicit_parameters(self) -> Literal[0, 1]:
        ...
    
    def is_bound(self) -> bool:
        ...
    
    def getattr(self, name: str, context: InferenceContext | None = ...):
        ...
    
    def igetattr(self, name: str, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        ...
    
    def infer_call_result(self, caller: SuccessfulInferenceResult | None, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """
        The boundnode of the regular context with a function called
        on ``object.__new__`` will be of type ``object``,
        which is incorrect for the argument in general.
        If no context is given the ``object.__new__`` call argument will
        be correctly inferred except when inside a call that requires
        the additional context (such as a classmethod) of the boundnode
        to determine which class the method was called from
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        ...
    


class BoundMethod(UnboundMethod):
    """A special node representing a method bound to an instance."""
    special_attributes = ...
    def __init__(self, proxy: nodes.FunctionDef | nodes.Lambda | UnboundMethod, bound: SuccessfulInferenceResult) -> None:
        ...
    
    def implicit_parameters(self) -> Literal[0, 1]:
        ...
    
    def is_bound(self) -> Literal[True]:
        ...
    
    def infer_call_result(self, caller: SuccessfulInferenceResult | None, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        ...
    


class Generator(BaseInstance):
    """A special node representing a generator.

    Proxied class is set once for all in raw_building.
    """
    special_attributes: objectmodel.GeneratorModel
    def __init__(self, parent: nodes.FunctionDef, generator_initial_context: InferenceContext | None = ...) -> None:
        ...
    
    def infer_yield_types(self) -> Iterator[InferenceResult]:
        ...
    
    def callable(self) -> Literal[False]:
        ...
    
    def pytype(self) -> str:
        ...
    
    def display_type(self) -> str:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class AsyncGenerator(Generator):
    """Special node representing an async generator."""
    def pytype(self) -> Literal["builtins.async_generator"]:
        ...
    
    def display_type(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class UnionType(BaseInstance):
    """Special node representing new style typing unions.

    Proxied class is set once for all in raw_building.
    """
    def __init__(self, left: UnionType | nodes.ClassDef | nodes.Const, right: UnionType | nodes.ClassDef | nodes.Const, parent: nodes.NodeNG | None = ...) -> None:
        ...
    
    def callable(self) -> Literal[False]:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        ...
    
    def pytype(self) -> Literal["types.UnionType"]:
        ...
    
    def display_type(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


