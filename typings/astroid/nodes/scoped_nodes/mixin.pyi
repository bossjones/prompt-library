"""
This type stub file was generated by pyright.
"""

from typing import TYPE_CHECKING, TypeVar, overload
from astroid.nodes import _base_nodes
from astroid.typing import InferenceResult, SuccessfulInferenceResult
from astroid import nodes

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
_T = TypeVar("_T")
class LocalsDictNodeNG(_base_nodes.LookupMixIn):
    """this class provides locals handling common to Module, FunctionDef
    and ClassDef nodes, including a dict like interface for direct access
    to locals information
    """
    locals: dict[str, list[InferenceResult]]
    def qname(self) -> str:
        """Get the 'qualified' name of the node.

        For example: module.name, module.class.name ...

        :returns: The qualified name.
        :rtype: str
        """
        ...
    
    def scope(self: _T) -> _T:
        """The first parent node defining a new scope.

        :returns: The first parent scope node.
        :rtype: Module or FunctionDef or ClassDef or Lambda or GenExpr
        """
        ...
    
    def scope_lookup(self, node: _base_nodes.LookupMixIn, name: str, offset: int = ...) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:
        """Lookup where the given variable is assigned.

        :param node: The node to look for assignments up to.
            Any assignments after the given node are ignored.

        :param name: The name of the variable to find assignments for.

        :param offset: The line offset to filter statements up to.

        :returns: This scope node and the list of assignments associated to the
            given name according to the scope where it has been found (locals,
            globals or builtin).
        """
        ...
    
    def set_local(self, name: str, stmt: nodes.NodeNG) -> None:
        """Define that the given name is declared in the given statement node.

        .. seealso:: :meth:`scope`

        :param name: The name that is being defined.

        :param stmt: The statement that defines the given name.
        """
        ...
    
    __setitem__ = ...
    @overload
    def add_local_node(self, child_node: nodes.ClassDef, name: str | None = ...) -> None:
        ...
    
    @overload
    def add_local_node(self, child_node: nodes.NodeNG, name: str) -> None:
        ...
    
    def add_local_node(self, child_node: nodes.NodeNG, name: str | None = ...) -> None:
        """Append a child that should alter the locals of this scope node.

        :param child_node: The child node that will alter locals.

        :param name: The name of the local that will be altered by
            the given child node.
        """
        ...
    
    def __getitem__(self, item: str) -> SuccessfulInferenceResult:
        """The first node the defines the given local.

        :param item: The name of the locally defined object.

        :raises KeyError: If the name is not defined.
        """
        ...
    
    def __iter__(self):
        """Iterate over the names of locals defined in this scoped node.

        :returns: The names of the defined locals.
        :rtype: iterable(str)
        """
        ...
    
    def keys(self):
        """The names of locals defined in this scoped node.

        :returns: The names of the defined locals.
        :rtype: list(str)
        """
        ...
    
    def values(self):
        """The nodes that define the locals in this scoped node.

        :returns: The nodes that define locals.
        :rtype: list(NodeNG)
        """
        ...
    
    def items(self):
        """Get the names of the locals and the node that defines the local.

        :returns: The names of locals and their associated node.
        :rtype: list(tuple(str, NodeNG))
        """
        ...
    
    def __contains__(self, name) -> bool:
        """Check if a local is defined in this scope.

        :param name: The name of the local to check for.
        :type name: str

        :returns: Whether this node has a local of the given name,
        """
        ...
    


class ComprehensionScope(LocalsDictNodeNG):
    """Scoping for different types of comprehensions."""
    scope_lookup = ...
    generators: list[nodes.Comprehension]


