"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator, Iterator, Sequence
from functools import cached_property
from typing import ClassVar, Literal, NoReturn, TYPE_CHECKING, TypeVar
from astroid import bases, nodes
from astroid.context import InferenceContext
from astroid.nodes import Arguments, Const, NodeNG, _base_nodes, node_classes
from astroid.nodes.scoped_nodes.mixin import ComprehensionScope, LocalsDictNodeNG
from astroid.nodes.utils import Position
from astroid.typing import InferBinaryOp, InferenceResult, SuccessfulInferenceResult
from astroid.nodes._base_nodes import LookupMixIn

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
ITER_METHODS = ...
EXCEPTION_BASE_CLASSES = ...
BUILTIN_DESCRIPTORS = ...
_T = TypeVar("_T")
def clean_typing_generic_mro(sequences: list[list[ClassDef]]) -> None:
    """A class can inherit from typing.Generic directly, as base,
    and as base of bases. The merged MRO must however only contain the last entry.
    To prepare for _c3_merge, remove some typing.Generic entries from
    sequences if multiple are present.

    This method will check if Generic is in inferred_bases and also
    part of bases_mro. If true, remove it from inferred_bases
    as well as its entry the bases_mro.

    Format sequences: [[self]] + bases_mro + [inferred_bases]
    """
    ...

def clean_duplicates_mro(sequences: list[list[ClassDef]], cls: ClassDef, context: InferenceContext | None) -> list[list[ClassDef]]:
    ...

def function_to_method(n, klass):
    ...

class Module(LocalsDictNodeNG):
    """Class representing an :class:`ast.Module` node.

    >>> import astroid
    >>> node = astroid.extract_node('import astroid')
    >>> node
    <Import l.1 at 0x7f23b2e4e5c0>
    >>> node.parent
    <Module l.0 at 0x7f23b2e4eda0>
    """
    _astroid_fields = ...
    doc_node: Const | None
    file_bytes: str | bytes | None = ...
    file_encoding: str | None = ...
    special_attributes = ...
    scope_attrs: ClassVar[set[str]] = ...
    _other_fields = ...
    _other_other_fields = ...
    def __init__(self, name: str, file: str | None = ..., path: Sequence[str] | None = ..., package: bool = ..., pure_python: bool = ...) -> None:
        ...
    
    def postinit(self, body: list[node_classes.NodeNG], *, doc_node: Const | None = ...):
        ...
    
    def stream(self):
        """Get a stream to the underlying file or bytes.

        :type: file or io.BytesIO or None
        """
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from where this node starts to where this node ends.

        :param lineno: Unused.

        :returns: The range of line numbers that this node belongs to.
        """
        ...
    
    def scope_lookup(self, node: LookupMixIn, name: str, offset: int = ...) -> tuple[LocalsDictNodeNG, list[node_classes.NodeNG]]:
        """Lookup where the given variable is assigned.

        :param node: The node to look for assignments up to.
            Any assignments after the given node are ignored.

        :param name: The name of the variable to find assignments for.

        :param offset: The line offset to filter statements up to.

        :returns: This scope node and the list of assignments associated to the
            given name according to the scope where it has been found (locals,
            globals or builtin).
        """
        ...
    
    def pytype(self) -> Literal["builtins.module"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def display_type(self) -> str:
        """A human readable type of this node.

        :returns: The type of this node.
        :rtype: str
        """
        ...
    
    def getattr(self, name, context: InferenceContext | None = ..., ignore_locals=...):
        ...
    
    def igetattr(self, name: str, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """Infer the possible values of the given variable.

        :param name: The name of the variable to infer.

        :returns: The inferred possible values.
        """
        ...
    
    def fully_defined(self) -> bool:
        """Check if this module has been build from a .py file.

        If so, the module contains a complete representation,
        including the code.

        :returns: Whether the module has been built from a .py file.
        """
        ...
    
    def statement(self, *, future: Literal[None, True] = ...) -> NoReturn:
        """The first parent node, including self, marked as statement node.

        When called on a :class:`Module` this raises a StatementMissing.
        """
        ...
    
    def previous_sibling(self):
        """The previous sibling statement.

        :returns: The previous sibling statement node.
        :rtype: NodeNG or None
        """
        ...
    
    def next_sibling(self):
        """The next sibling statement node.

        :returns: The next sibling statement node.
        :rtype: NodeNG or None
        """
        ...
    
    _absolute_import_activated = ...
    def absolute_import_activated(self) -> bool:
        """Whether :pep:`328` absolute import behaviour has been enabled.

        :returns: Whether :pep:`328` has been enabled.
        """
        ...
    
    def import_module(self, modname: str, relative_only: bool = ..., level: int | None = ..., use_cache: bool = ...) -> Module:
        """Get the ast for a given module as if imported from this module.

        :param modname: The name of the module to "import".

        :param relative_only: Whether to only consider relative imports.

        :param level: The level of relative import.

        :param use_cache: Whether to use the astroid_cache of modules.

        :returns: The imported module ast.
        """
        ...
    
    def relative_to_absolute_name(self, modname: str, level: int | None) -> str:
        """Get the absolute module name for a relative import.

        The relative import can be implicit or explicit.

        :param modname: The module name to convert.

        :param level: The level of relative import.

        :returns: The absolute module name.

        :raises TooManyLevelsError: When the relative import refers to a
            module too far above this one.
        """
        ...
    
    def wildcard_import_names(self):
        """The list of imported names when this module is 'wildcard imported'.

        It doesn't include the '__builtins__' name which is added by the
        current CPython implementation of wildcard imports.

        :returns: The list of imported names.
        :rtype: list(str)
        """
        ...
    
    def public_names(self):
        """The list of the names that are publicly available in this module.

        :returns: The list of public names.
        :rtype: list(str)
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> bool:
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`Module` this is always ``True``.
        """
        ...
    
    def get_children(self):
        ...
    
    def frame(self: _T, *, future: Literal[None, True] = ...) -> _T:
        """The node's frame node.

        A frame node is a :class:`Module`, :class:`FunctionDef`,
        :class:`ClassDef` or :class:`Lambda`.

        :returns: The node itself.
        """
        ...
    


class GeneratorExp(ComprehensionScope):
    """Class representing an :class:`ast.GeneratorExp` node.

    >>> import astroid
    >>> node = astroid.extract_node('(thing for thing in things if thing)')
    >>> node
    <GeneratorExp l.1 at 0x7f23b2e4e400>
    """
    _astroid_fields = ...
    _other_other_fields = ...
    elt: NodeNG
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, elt: NodeNG, generators: list[nodes.Comprehension]) -> None:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`GeneratorExp` this is always ``True``.
        """
        ...
    
    def get_children(self):
        ...
    


class DictComp(ComprehensionScope):
    """Class representing an :class:`ast.DictComp` node.

    >>> import astroid
    >>> node = astroid.extract_node('{k:v for k, v in things if k > v}')
    >>> node
    <DictComp l.1 at 0x7f23b2e41d68>
    """
    _astroid_fields = ...
    _other_other_fields = ...
    key: NodeNG
    value: NodeNG
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, key: NodeNG, value: NodeNG, generators: list[nodes.Comprehension]) -> None:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...):
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`DictComp` this is always :class:`Uninferable`.
        :rtype: Uninferable
        """
        ...
    
    def get_children(self):
        ...
    


class SetComp(ComprehensionScope):
    """Class representing an :class:`ast.SetComp` node.

    >>> import astroid
    >>> node = astroid.extract_node('{thing for thing in things if thing}')
    >>> node
    <SetComp l.1 at 0x7f23b2e41898>
    """
    _astroid_fields = ...
    _other_other_fields = ...
    elt: NodeNG
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, elt: NodeNG, generators: list[nodes.Comprehension]) -> None:
        ...
    
    def bool_value(self, context: InferenceContext | None = ...):
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`SetComp` this is always :class:`Uninferable`.
        :rtype: Uninferable
        """
        ...
    
    def get_children(self):
        ...
    


class ListComp(ComprehensionScope):
    """Class representing an :class:`ast.ListComp` node.

    >>> import astroid
    >>> node = astroid.extract_node('[thing for thing in things if thing]')
    >>> node
    <ListComp l.1 at 0x7f23b2e418d0>
    """
    _astroid_fields = ...
    _other_other_fields = ...
    elt: NodeNG
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, elt: NodeNG, generators: list[nodes.Comprehension]):
        ...
    
    def bool_value(self, context: InferenceContext | None = ...):
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`ListComp` this is always :class:`Uninferable`.
        :rtype: Uninferable
        """
        ...
    
    def get_children(self):
        ...
    


class Lambda(_base_nodes.FilterStmtsBaseNode, LocalsDictNodeNG):
    """Class representing an :class:`ast.Lambda` node.

    >>> import astroid
    >>> node = astroid.extract_node('lambda arg: arg + 1')
    >>> node
    <Lambda.<lambda> l.1 at 0x7f23b2e41518>
    """
    _astroid_fields: ClassVar[tuple[str, ...]] = ...
    _other_other_fields: ClassVar[tuple[str, ...]] = ...
    name = ...
    is_lambda = ...
    special_attributes = ...
    args: Arguments
    body: NodeNG
    def implicit_parameters(self) -> Literal[0]:
        ...
    
    @property
    def type(self) -> Literal["method", "function"]:
        """Whether this is a method or function.

        :returns: 'method' if this is a method, 'function' otherwise.
        """
        ...
    
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, args: Arguments, body: NodeNG) -> None:
        ...
    
    def pytype(self) -> Literal["builtins.instancemethod", "builtins.function"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def display_type(self) -> str:
        """A human readable type of this node.

        :returns: The type of this node.
        :rtype: str
        """
        ...
    
    def callable(self) -> Literal[True]:
        """Whether this node defines something that is callable.

        :returns: Whether this defines something that is callable
            For a :class:`Lambda` this is always ``True``.
        """
        ...
    
    def argnames(self) -> list[str]:
        """Get the names of each of the arguments, including that
        of the collections of variable-length arguments ("args", "kwargs",
        etc.), as well as positional-only and keyword-only arguments.

        :returns: The names of the arguments.
        :rtype: list(str)
        """
        ...
    
    def infer_call_result(self, caller: SuccessfulInferenceResult | None, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """Infer what the function returns when called."""
        ...
    
    def scope_lookup(self, node: LookupMixIn, name: str, offset: int = ...) -> tuple[LocalsDictNodeNG, list[NodeNG]]:
        """Lookup where the given names is assigned.

        :param node: The node to look for assignments up to.
            Any assignments after the given node are ignored.

        :param name: The name to find assignments for.

        :param offset: The line offset to filter statements up to.

        :returns: This scope node and the list of assignments associated to the
            given name according to the scope where it has been found (locals,
            globals or builtin).
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`Lambda` this is always ``True``.
        """
        ...
    
    def get_children(self):
        ...
    
    def frame(self: _T, *, future: Literal[None, True] = ...) -> _T:
        """The node's frame node.

        A frame node is a :class:`Module`, :class:`FunctionDef`,
        :class:`ClassDef` or :class:`Lambda`.

        :returns: The node itself.
        """
        ...
    
    def getattr(self, name: str, context: InferenceContext | None = ...) -> list[NodeNG]:
        ...
    


class FunctionDef(_base_nodes.MultiLineBlockNode, _base_nodes.FilterStmtsBaseNode, _base_nodes.Statement, LocalsDictNodeNG):
    """Class representing an :class:`ast.FunctionDef`.

    >>> import astroid
    >>> node = astroid.extract_node('''
    ... def my_func(arg):
    ...     return arg + 1
    ... ''')
    >>> node
    <FunctionDef.my_func l.2 at 0x7f23b2e71e10>
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    returns = ...
    decorators: node_classes.Decorators | None
    doc_node: Const | None
    args: Arguments
    is_function = ...
    type_annotation = ...
    type_comment_args = ...
    type_comment_returns = ...
    _other_fields = ...
    _other_other_fields = ...
    _type = ...
    name = ...
    special_attributes = ...
    def __init__(self, name: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, args: Arguments, body: list[NodeNG], decorators: node_classes.Decorators | None = ..., returns=..., type_comment_returns=..., type_comment_args=..., *, position: Position | None = ..., doc_node: Const | None = ..., type_params: (list[nodes.TypeVar | nodes.ParamSpec | nodes.TypeVarTuple] | None) = ...):
        """Do some setup after initialisation.

        :param args: The arguments that the function takes.

        :param body: The contents of the function body.

        :param decorators: The decorators that are applied to this
            method or function.
        :params type_comment_returns:
            The return type annotation passed via a type comment.
        :params type_comment_args:
            The args type annotation passed via a type comment.
        :params position:
            Position of function keyword(s) and name.
        :param doc_node:
            The doc node associated with this node.
        :param type_params:
            The type_params associated with this node.
        """
        ...
    
    @cached_property
    def extra_decorators(self) -> list[node_classes.Call]:
        """The extra decorators that this function can have.

        Additional decorators are considered when they are used as
        assignments, as in ``method = staticmethod(method)``.
        The property will return all the callables that are used for
        decoration.
        """
        ...
    
    def pytype(self) -> Literal["builtins.instancemethod", "builtins.function"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def display_type(self) -> str:
        """A human readable type of this node.

        :returns: The type of this node.
        :rtype: str
        """
        ...
    
    def callable(self) -> Literal[True]:
        ...
    
    def argnames(self) -> list[str]:
        """Get the names of each of the arguments, including that
        of the collections of variable-length arguments ("args", "kwargs",
        etc.), as well as positional-only and keyword-only arguments.

        :returns: The names of the arguments.
        :rtype: list(str)
        """
        ...
    
    def getattr(self, name: str, context: InferenceContext | None = ...) -> list[NodeNG]:
        ...
    
    @cached_property
    def type(self) -> str:
        """The function type for this node.

        Possible values are: method, function, staticmethod, classmethod.
        """
        ...
    
    @cached_property
    def fromlineno(self) -> int:
        """The first line that this node appears on in the source code.

        Can also return 0 if the line can not be determined.
        """
        ...
    
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def implicit_parameters(self) -> Literal[0, 1]:
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from the given line number to where this node ends.

        :param lineno: Unused.

        :returns: The range of line numbers that this node belongs to,
        """
        ...
    
    def igetattr(self, name: str, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """Inferred getattr, which returns an iterator of inferred statements."""
        ...
    
    def is_method(self) -> bool:
        """Check if this function node represents a method.

        :returns: Whether this is a method.
        """
        ...
    
    def decoratornames(self, context: InferenceContext | None = ...) -> set[str]:
        """Get the qualified names of each of the decorators on this function.

        :param context:
            An inference context that can be passed to inference functions
        :returns: The names of the decorators.
        """
        ...
    
    def is_bound(self) -> bool:
        """Check if the function is bound to an instance or class.

        :returns: Whether the function is bound to an instance or class.
        """
        ...
    
    def is_abstract(self, pass_is_abstract=..., any_raise_is_abstract=...) -> bool:
        """Check if the method is abstract.

        A method is considered abstract if any of the following is true:
        * The only statement is 'raise NotImplementedError'
        * The only statement is 'raise <SomeException>' and any_raise_is_abstract is True
        * The only statement is 'pass' and pass_is_abstract is True
        * The method is annotated with abc.astractproperty/abc.abstractmethod

        :returns: Whether the method is abstract.
        """
        ...
    
    def is_generator(self) -> bool:
        """Check if this is a generator function.

        :returns: Whether this is a generator function.
        """
        ...
    
    def infer_yield_result(self, context: InferenceContext | None = ...):
        """Infer what the function yields when called

        :returns: What the function yields
        :rtype: iterable(NodeNG or Uninferable) or None
        """
        ...
    
    def infer_call_result(self, caller: SuccessfulInferenceResult | None, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """Infer what the function returns when called."""
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> bool:
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`FunctionDef` this is always ``True``.
        """
        ...
    
    def get_children(self):
        ...
    
    def scope_lookup(self, node: LookupMixIn, name: str, offset: int = ...) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:
        """Lookup where the given name is assigned."""
        ...
    
    def frame(self: _T, *, future: Literal[None, True] = ...) -> _T:
        """The node's frame node.

        A frame node is a :class:`Module`, :class:`FunctionDef`,
        :class:`ClassDef` or :class:`Lambda`.

        :returns: The node itself.
        """
        ...
    


class AsyncFunctionDef(FunctionDef):
    """Class representing an :class:`ast.FunctionDef` node.

    A :class:`AsyncFunctionDef` is an asynchronous function
    created with the `async` keyword.

    >>> import astroid
    >>> node = astroid.extract_node('''
    async def func(things):
        async for thing in things:
            print(thing)
    ''')
    >>> node
    <AsyncFunctionDef.func l.2 at 0x7f23b2e416d8>
    >>> node.body[0]
    <AsyncFor l.3 at 0x7f23b2e417b8>
    """
    ...


def get_wrapping_class(node):
    """Get the class that wraps the given node.

    We consider that a class wraps a node if the class
    is a parent for the said node.

    :returns: The class that wraps the given node
    :rtype: ClassDef or None
    """
    ...

class ClassDef(_base_nodes.FilterStmtsBaseNode, LocalsDictNodeNG, _base_nodes.Statement):
    """Class representing an :class:`ast.ClassDef` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    class Thing:
        def my_meth(self, arg):
            return arg + self.offset
    ''')
    >>> node
    <ClassDef.Thing l.2 at 0x7f23b2e9e748>
    """
    _astroid_fields = ...
    decorators = ...
    special_attributes = ...
    _type: Literal["class", "exception", "metaclass"] | None = ...
    _metaclass: NodeNG | None = ...
    _metaclass_hack = ...
    hide = ...
    type = ...
    _other_fields = ...
    _other_other_fields = ...
    _newstyle: bool | None = ...
    def __init__(self, name: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    infer_binary_op: ClassVar[InferBinaryOp[ClassDef]] = ...
    def implicit_parameters(self) -> Literal[1]:
        ...
    
    def implicit_locals(self):
        """Get implicitly defined class definition locals.

        :returns: the the name and Const pair for each local
        :rtype: tuple(tuple(str, node_classes.Const), ...)
        """
        ...
    
    def postinit(self, bases: list[SuccessfulInferenceResult], body: list[NodeNG], decorators: node_classes.Decorators | None, newstyle: bool | None = ..., metaclass: NodeNG | None = ..., keywords: list[node_classes.Keyword] | None = ..., *, position: Position | None = ..., doc_node: Const | None = ..., type_params: (list[nodes.TypeVar | nodes.ParamSpec | nodes.TypeVarTuple] | None) = ...) -> None:
        ...
    
    _newstyle = ...
    newstyle = ...
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from the given line number to where this node ends.

        :param lineno: Unused.

        :returns: The range of line numbers that this node belongs to,
        """
        ...
    
    def pytype(self) -> Literal["builtins.type", "builtins.classobj"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def display_type(self) -> str:
        """A human readable type of this node.

        :returns: The type of this node.
        :rtype: str
        """
        ...
    
    def callable(self) -> bool:
        """Whether this node defines something that is callable.

        :returns: Whether this defines something that is callable.
            For a :class:`ClassDef` this is always ``True``.
        """
        ...
    
    def is_subtype_of(self, type_name, context: InferenceContext | None = ...) -> bool:
        """Whether this class is a subtype of the given type.

        :param type_name: The name of the type of check against.
        :type type_name: str

        :returns: Whether this class is a subtype of the given type.
        """
        ...
    
    def infer_call_result(self, caller: SuccessfulInferenceResult | None, context: InferenceContext | None = ...) -> Iterator[InferenceResult]:
        """infer what a class is returning when called"""
        ...
    
    def scope_lookup(self, node: LookupMixIn, name: str, offset: int = ...) -> tuple[LocalsDictNodeNG, list[nodes.NodeNG]]:
        """Lookup where the given name is assigned.

        :param node: The node to look for assignments up to.
            Any assignments after the given node are ignored.

        :param name: The name to find assignments for.

        :param offset: The line offset to filter statements up to.

        :returns: This scope node and the list of assignments associated to the
            given name according to the scope where it has been found (locals,
            globals or builtin).
        """
        ...
    
    @property
    def basenames(self):
        """The names of the parent classes

        Names are given in the order they appear in the class definition.

        :type: list(str)
        """
        ...
    
    def ancestors(self, recurs: bool = ..., context: InferenceContext | None = ...) -> Generator[ClassDef]:
        """Iterate over the base classes in prefixed depth first order.

        :param recurs: Whether to recurse or return direct ancestors only.

        :returns: The base classes
        """
        ...
    
    def local_attr_ancestors(self, name, context: InferenceContext | None = ...):
        """Iterate over the parents that define the given name.

        :param name: The name to find definitions for.
        :type name: str

        :returns: The parents that define the given name.
        :rtype: iterable(NodeNG)
        """
        ...
    
    def instance_attr_ancestors(self, name, context: InferenceContext | None = ...):
        """Iterate over the parents that define the given name as an attribute.

        :param name: The name to find definitions for.
        :type name: str

        :returns: The parents that define the given name as
            an instance attribute.
        :rtype: iterable(NodeNG)
        """
        ...
    
    def has_base(self, node) -> bool:
        """Whether this class directly inherits from the given node.

        :param node: The node to check for.
        :type node: NodeNG

        :returns: Whether this class directly inherits from the given node.
        """
        ...
    
    def local_attr(self, name, context: InferenceContext | None = ...):
        """Get the list of assign nodes associated to the given name.

        Assignments are looked for in both this class and in parents.

        :returns: The list of assignments to the given name.
        :rtype: list(NodeNG)

        :raises AttributeInferenceError: If no attribute with this name
            can be found in this class or parent classes.
        """
        ...
    
    def instance_attr(self, name, context: InferenceContext | None = ...):
        """Get the list of nodes associated to the given attribute name.

        Assignments are looked for in both this class and in parents.

        :returns: The list of assignments to the given name.
        :rtype: list(NodeNG)

        :raises AttributeInferenceError: If no attribute with this name
            can be found in this class or parent classes.
        """
        ...
    
    def instantiate_class(self) -> bases.Instance:
        """Get an :class:`Instance` of the :class:`ClassDef` node.

        :returns: An :class:`Instance` of the :class:`ClassDef` node
        """
        ...
    
    def getattr(self, name: str, context: InferenceContext | None = ..., class_context: bool = ...) -> list[InferenceResult]:
        """Get an attribute from this class, using Python's attribute semantic.

        This method doesn't look in the :attr:`instance_attrs` dictionary
        since it is done by an :class:`Instance` proxy at inference time.
        It may return an :class:`Uninferable` object if
        the attribute has not been
        found, but a ``__getattr__`` or ``__getattribute__`` method is defined.
        If ``class_context`` is given, then it is considered that the
        attribute is accessed from a class context,
        e.g. ClassDef.attribute, otherwise it might have been accessed
        from an instance as well. If ``class_context`` is used in that
        case, then a lookup in the implicit metaclass and the explicit
        metaclass will be done.

        :param name: The attribute to look for.

        :param class_context: Whether the attribute can be accessed statically.

        :returns: The attribute.

        :raises AttributeInferenceError: If the attribute cannot be inferred.
        """
        ...
    
    def igetattr(self, name: str, context: InferenceContext | None = ..., class_context: bool = ...) -> Iterator[InferenceResult]:
        """Infer the possible values of the given variable.

        :param name: The name of the variable to infer.

        :returns: The inferred possible values.
        """
        ...
    
    def has_dynamic_getattr(self, context: InferenceContext | None = ...) -> bool:
        """Check if the class has a custom __getattr__ or __getattribute__.

        If any such method is found and it is not from
        builtins, nor from an extension module, then the function
        will return True.

        :returns: Whether the class has a custom __getattr__ or __getattribute__.
        """
        ...
    
    def getitem(self, index, context: InferenceContext | None = ...):
        """Return the inference of a subscript.

        This is basically looking up the method in the metaclass and calling it.

        :returns: The inferred value of a subscript to this class.
        :rtype: NodeNG

        :raises AstroidTypeError: If this class does not define a
            ``__getitem__`` method.
        """
        ...
    
    def methods(self):
        """Iterate over all of the method defined in this class and its parents.

        :returns: The methods defined on the class.
        :rtype: iterable(FunctionDef)
        """
        ...
    
    def mymethods(self):
        """Iterate over all of the method defined in this class only.

        :returns: The methods defined on the class.
        :rtype: iterable(FunctionDef)
        """
        ...
    
    def implicit_metaclass(self):
        """Get the implicit metaclass of the current class.

        For newstyle classes, this will return an instance of builtins.type.
        For oldstyle classes, it will simply return None, since there's
        no implicit metaclass there.

        :returns: The metaclass.
        :rtype: builtins.type or None
        """
        ...
    
    def declared_metaclass(self, context: InferenceContext | None = ...) -> SuccessfulInferenceResult | None:
        """Return the explicit declared metaclass for the current class.

        An explicit declared metaclass is defined
        either by passing the ``metaclass`` keyword argument
        in the class definition line (Python 3) or (Python 2) by
        having a ``__metaclass__`` class attribute, or if there are
        no explicit bases but there is a global ``__metaclass__`` variable.

        :returns: The metaclass of this class,
            or None if one could not be found.
        """
        ...
    
    def metaclass(self, context: InferenceContext | None = ...) -> SuccessfulInferenceResult | None:
        """Get the metaclass of this class.

        If this class does not define explicitly a metaclass,
        then the first defined metaclass in ancestors will be used
        instead.

        :returns: The metaclass of this class.
        """
        ...
    
    def has_metaclass_hack(self):
        ...
    
    def slots(self):
        ...
    
    def mro(self, context: InferenceContext | None = ...) -> list[ClassDef]:
        """Get the method resolution order, using C3 linearization.

        :returns: The list of ancestors, sorted by the mro.
        :rtype: list(NodeNG)
        :raises DuplicateBasesError: Duplicate bases in the same class base
        :raises InconsistentMroError: A class' MRO is inconsistent
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> Literal[True]:
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
            For a :class:`ClassDef` this is always ``True``.
        """
        ...
    
    def get_children(self):
        ...
    
    def frame(self: _T, *, future: Literal[None, True] = ...) -> _T:
        """The node's frame node.

        A frame node is a :class:`Module`, :class:`FunctionDef`,
        :class:`ClassDef` or :class:`Lambda`.

        :returns: The node itself.
        """
        ...
    


