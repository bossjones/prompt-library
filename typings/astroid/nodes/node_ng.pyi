"""
This type stub file was generated by pyright.
"""

import sys
from collections.abc import Generator, Iterator
from functools import cached_property
from typing import Any, ClassVar, Literal, Self, TYPE_CHECKING, TypeVar, Union, overload
from astroid import nodes
from astroid.context import InferenceContext
from astroid.nodes.as_string import AsStringVisitor
from astroid.typing import InferFn, InferenceResult
from astroid.nodes import _base_nodes

if sys.version_info >= (3, 11):
    ...
else:
    ...
if TYPE_CHECKING:
    ...
_NodesT = TypeVar("_NodesT", bound="NodeNG")
_NodesT2 = TypeVar("_NodesT2", bound="NodeNG")
_NodesT3 = TypeVar("_NodesT3", bound="NodeNG")
SkipKlassT = Union[None, type["NodeNG"], tuple[type["NodeNG"], ...]]
class NodeNG:
    """A node of the new Abstract Syntax Tree (AST).

    This is the base class for all Astroid node classes.
    """
    is_statement: ClassVar[bool] = ...
    optional_assign: ClassVar[bool] = ...
    is_function: ClassVar[bool] = ...
    is_lambda: ClassVar[bool] = ...
    _astroid_fields: ClassVar[tuple[str, ...]] = ...
    _other_fields: ClassVar[tuple[str, ...]] = ...
    _other_other_fields: ClassVar[tuple[str, ...]] = ...
    _explicit_inference: InferFn[Self] | None = ...
    def __init__(self, lineno: int | None, col_offset: int | None, parent: NodeNG | None, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...

    def infer(self, context: InferenceContext | None = ..., **kwargs: Any) -> Generator[InferenceResult]:
        """Get a generator of the inferred values.

        This is the main entry point to the inference system.

        .. seealso:: :ref:`inference`

        If the instance has some explicit inference function set, it will be
        called instead of the default interface.

        :returns: The inferred values.
        :rtype: iterable
        """
        ...

    def repr_name(self) -> str:
        """Get a name for nice representation.

        This is either :attr:`name`, :attr:`attrname`, or the empty string.
        """
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def accept(self, visitor: AsStringVisitor) -> str:
        """Visit this node using the given visitor."""
        ...

    def get_children(self) -> Iterator[NodeNG]:
        """Get the child nodes below this node."""
        ...

    def last_child(self) -> NodeNG | None:
        """An optimized version of list(get_children())[-1]."""
        ...

    def node_ancestors(self) -> Iterator[NodeNG]:
        """Yield parent, grandparent, etc until there are no more."""
        ...

    def parent_of(self, node) -> bool:
        """Check if this node is the parent of the given node.

        :param node: The node to check if it is the child.
        :type node: NodeNG

        :returns: Whether this node is the parent of the given node.
        """
        ...

    def statement(self, *, future: Literal[None, True] = ...) -> _base_nodes.Statement:
        """The first parent node, including self, marked as statement node.

        :raises StatementMissing: If self has no parent attribute.
        """
        ...

    def frame(self, *, future: Literal[None, True] = ...) -> nodes.FunctionDef | nodes.Module | nodes.ClassDef | nodes.Lambda:
        """The first parent frame node.

        A frame node is a :class:`Module`, :class:`FunctionDef`,
        :class:`ClassDef` or :class:`Lambda`.

        :returns: The first parent frame node.
        :raises ParentMissingError: If self has no parent attribute.
        """
        ...

    def scope(self) -> nodes.LocalsDictNodeNG:
        """The first parent node defining a new scope.

        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.

        :returns: The first parent scope node.
        """
        ...

    def root(self) -> nodes.Module:
        """Return the root node of the syntax tree.

        :returns: The root node.
        """
        ...

    def child_sequence(self, child): # -> list[Any] | tuple | list:
        """Search for the sequence that contains this child.

        :param child: The child node to search sequences for.
        :type child: NodeNG

        :returns: The sequence containing the given child node.
        :rtype: iterable(NodeNG)

        :raises AstroidError: If no sequence could be found that contains
            the given child.
        """
        ...

    def locate_child(self, child): # -> tuple[str, Any] | tuple[str, tuple | list]:
        """Find the field of this node that contains the given child.

        :param child: The child node to search fields for.
        :type child: NodeNG

        :returns: A tuple of the name of the field that contains the child,
            and the sequence or node that contains the child node.
        :rtype: tuple(str, iterable(NodeNG) or NodeNG)

        :raises AstroidError: If no field could be found that contains
            the given child.
        """
        ...

    def next_sibling(self):
        """The next sibling statement node.

        :returns: The next sibling statement node.
        :rtype: NodeNG or None
        """
        ...

    def previous_sibling(self):
        """The previous sibling statement.

        :returns: The previous sibling statement node.
        :rtype: NodeNG or None
        """
        ...

    @cached_property
    def fromlineno(self) -> int:
        """The first line that this node appears on in the source code.

        Can also return 0 if the line can not be determined.
        """
        ...

    @cached_property
    def tolineno(self) -> int:
        """The last line that this node appears on in the source code.

        Can also return 0 if the line can not be determined.
        """
        ...

    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from the given line number to where this node ends.

        :param lineno: The line number to start the range at.

        :returns: The range of line numbers that this node belongs to,
            starting at the given line number.
        """
        ...

    def set_local(self, name: str, stmt: NodeNG) -> None:
        """Define that the given name is declared in the given statement node.

        This definition is stored on the parent scope node.

        .. seealso:: :meth:`scope`

        :param name: The name that is being defined.

        :param stmt: The statement that defines the given name.
        """
        ...

    @overload
    def nodes_of_class(self, klass: type[_NodesT], skip_klass: SkipKlassT = ...) -> Iterator[_NodesT]:
        ...

    @overload
    def nodes_of_class(self, klass: tuple[type[_NodesT], type[_NodesT2]], skip_klass: SkipKlassT = ...) -> Iterator[_NodesT] | Iterator[_NodesT2]:
        ...

    @overload
    def nodes_of_class(self, klass: tuple[type[_NodesT], type[_NodesT2], type[_NodesT3]], skip_klass: SkipKlassT = ...) -> Iterator[_NodesT] | Iterator[_NodesT2] | Iterator[_NodesT3]:
        ...

    @overload
    def nodes_of_class(self, klass: tuple[type[_NodesT], ...], skip_klass: SkipKlassT = ...) -> Iterator[_NodesT]:
        ...

    def nodes_of_class(self, klass: (type[_NodesT] | tuple[type[_NodesT], type[_NodesT2]] | tuple[type[_NodesT], type[_NodesT2], type[_NodesT3]] | tuple[type[_NodesT], ...]), skip_klass: SkipKlassT = ...) -> Iterator[_NodesT] | Iterator[_NodesT2] | Iterator[_NodesT3]:
        """Get the nodes (including this one or below) of the given types.

        :param klass: The types of node to search for.

        :param skip_klass: The types of node to ignore. This is useful to ignore
            subclasses of :attr:`klass`.

        :returns: The node of the given types.
        """
        ...

    def inferred(self): # -> list[InferenceResult]:
        """Get a list of the inferred values.

        .. seealso:: :ref:`inference`

        :returns: The inferred values.
        :rtype: list
        """
        ...

    def instantiate_class(self): # -> Self:
        """Instantiate an instance of the defined class.

        .. note::

            On anything other than a :class:`ClassDef` this will return self.

        :returns: An instance of the defined class.
        :rtype: object
        """
        ...

    def has_base(self, node) -> bool:
        """Check if this node inherits from the given type.

        :param node: The node defining the base to look for.
            Usually this is a :class:`Name` node.
        :type node: NodeNG
        """
        ...

    def callable(self) -> bool:
        """Whether this node defines something that is callable.

        :returns: Whether this defines something that is callable.
        """
        ...

    def eq(self, value) -> bool:
        ...

    def as_string(self) -> str:
        """Get the source code that this node represents."""
        ...

    def repr_tree(self, ids=..., include_linenos=..., ast_state=..., indent=..., max_depth=..., max_width=...) -> str:
        """Get a string representation of the AST from this node.

        :param ids: If true, includes the ids with the node type names.
        :type ids: bool

        :param include_linenos: If true, includes the line numbers and
            column offsets.
        :type include_linenos: bool

        :param ast_state: If true, includes information derived from
            the whole AST like local and global variables.
        :type ast_state: bool

        :param indent: A string to use to indent the output string.
        :type indent: str

        :param max_depth: If set to a positive integer, won't return
            nodes deeper than max_depth in the string.
        :type max_depth: int

        :param max_width: Attempt to format the output string to stay
            within this number of characters, but can exceed it under some
            circumstances. Only positive integer values are valid, the default is 80.
        :type max_width: int

        :returns: The string representation of the AST.
        :rtype: str
        """
        ...

    def bool_value(self, context: InferenceContext | None = ...): # -> UninferableBase:
        """Determine the boolean value of this node.

        The boolean value of a node can have three
        possible values:

            * False: For instance, empty data structures,
              False, empty strings, instances which return
              explicitly False from the __nonzero__ / __bool__
              method.
            * True: Most of constructs are True by default:
              classes, functions, modules etc
            * Uninferable: The inference engine is uncertain of the
              node's value.

        :returns: The boolean value of this node.
        :rtype: bool or Uninferable
        """
        ...

    def op_precedence(self): # -> int:
        ...

    def op_left_associative(self) -> bool:
        ...
