"""
This type stub file was generated by pyright.
"""

import abc
import sys
import typing
from collections.abc import Callable, Generator, Iterable, Iterator
from functools import cached_property
from typing import Any, ClassVar, Literal, Optional, Self, TYPE_CHECKING, Union
from astroid import decorators, nodes, util
from astroid.bases import Instance
from astroid.const import Context
from astroid.context import InferenceContext
from astroid.nodes import LocalsDictNodeNG, _base_nodes
from astroid.nodes.node_ng import NodeNG
from astroid.typing import ConstFactoryResult, InferenceErrorInfo, InferenceResult, SuccessfulInferenceResult

"""
This type stub file was generated by pyright.
"""
if sys.version_info >= (3, 11):
    ...
else:
    ...
if TYPE_CHECKING:
    ...
_NodesT = typing.TypeVar("_NodesT", bound=NodeNG)
_BadOpMessageT = typing.TypeVar("_BadOpMessageT", bound=util.BadOperationMessage)
AssignedStmtsPossibleNode = Union["List", "Tuple", "AssignName", "AssignAttr", None]
AssignedStmtsCall = Callable[[_NodesT, AssignedStmtsPossibleNode, Optional[InferenceContext], Optional[list[int]]], Any,]
InferBinaryOperation = Callable[[_NodesT, Optional[InferenceContext]], Generator[Union[InferenceResult, _BadOpMessageT]],]
InferLHS = Callable[[_NodesT, Optional[InferenceContext]], Generator[InferenceResult, None, Optional[InferenceErrorInfo]],]
InferUnaryOp = Callable[[_NodesT, str], ConstFactoryResult]
@decorators.raise_if_nothing_inferred
def unpack_infer(stmt, context: InferenceContext | None = ...):
    """recursively generate nodes inferred by the given statement.
    If the inferred value is a list or a tuple, recurse on the elements
    """
    ...

def are_exclusive(stmt1, stmt2, exceptions: list[str] | None = ...) -> bool:
    """return true if the two given statements are mutually exclusive

    `exceptions` may be a list of exception names. If specified, discard If
    branches and check one of the statement is in an exception handler catching
    one of the given exceptions.

    algorithm :
     1) index stmt1's parents
     2) climb among stmt2's parents until we find a common parent
     3) if the common parent is a If or Try statement, look if nodes are
        in exclusive branches
    """
    ...

_SLICE_SENTINEL = ...
class BaseContainer(_base_nodes.ParentAssignNode, Instance, metaclass=abc.ABCMeta):
    """Base class for Set, FrozenSet, Tuple and List."""
    _astroid_fields = ...
    def __init__(self, lineno: int | None, col_offset: int | None, parent: NodeNG | None, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, elts: list[SuccessfulInferenceResult]) -> None:
        ...
    
    @classmethod
    def from_elements(cls, elts: Iterable[Any]) -> Self:
        """Create a node of this type from the given list of elements.

        :param elts: The list of elements that the node should contain.

        :returns: A new node containing the given elements.
        """
        ...
    
    def itered(self):
        """An iterator over the elements this node contains.

        :returns: The contents of this node.
        :rtype: iterable(NodeNG)
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...) -> bool:
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
        """
        ...
    
    @abc.abstractmethod
    def pytype(self) -> str:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def get_children(self):
        ...
    


class AssignName(_base_nodes.NoChildrenNode, _base_nodes.LookupMixIn, _base_nodes.ParentAssignNode):
    """Variation of :class:`ast.Assign` representing assignment to a name.

    An :class:`AssignName` is the name of something that is assigned to.
    This includes variables defined in a function signature or in a loop.

    >>> import astroid
    >>> node = astroid.extract_node('variable = range(10)')
    >>> node
    <Assign l.1 at 0x7effe1db8550>
    >>> list(node.get_children())
    [<AssignName.variable l.1 at 0x7effe1db8748>, <Call l.1 at 0x7effe1db8630>]
    >>> list(node.get_children())[0].as_string()
    'variable'
    """
    _other_fields = ...
    def __init__(self, name: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    assigned_stmts = ...
    @decorators.raise_if_nothing_inferred
    def infer_lhs(self, context: InferenceContext | None = ..., **kwargs: Any) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:
        """Infer a Name: use name lookup rules.

        Same implementation as Name._infer."""
        ...
    


class DelName(_base_nodes.NoChildrenNode, _base_nodes.LookupMixIn, _base_nodes.ParentAssignNode):
    """Variation of :class:`ast.Delete` representing deletion of a name.

    A :class:`DelName` is the name of something that is deleted.

    >>> import astroid
    >>> node = astroid.extract_node("del variable #@")
    >>> list(node.get_children())
    [<DelName.variable l.1 at 0x7effe1da4d30>]
    >>> list(node.get_children())[0].as_string()
    'variable'
    """
    _other_fields = ...
    def __init__(self, name: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    


class Name(_base_nodes.LookupMixIn, _base_nodes.NoChildrenNode):
    """Class representing an :class:`ast.Name` node.

    A :class:`Name` node is something that is named, but not covered by
    :class:`AssignName` or :class:`DelName`.

    >>> import astroid
    >>> node = astroid.extract_node('range(10)')
    >>> node
    <Call l.1 at 0x7effe1db8710>
    >>> list(node.get_children())
    [<Name.range l.1 at 0x7effe1db86a0>, <Const.int l.1 at 0x7effe1db8518>]
    >>> list(node.get_children())[0].as_string()
    'range'
    """
    _other_fields = ...
    def __init__(self, name: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    


DEPRECATED_ARGUMENT_DEFAULT = ...
class Arguments(_base_nodes.AssignTypeNode):
    """Class representing an :class:`ast.arguments` node.

    An :class:`Arguments` node represents that arguments in a
    function definition.

    >>> import astroid
    >>> node = astroid.extract_node('def foo(bar): pass')
    >>> node
    <FunctionDef.foo l.1 at 0x7effe1db8198>
    >>> node.args
    <Arguments l.1 at 0x7effe1db82e8>
    """
    _astroid_fields = ...
    _other_fields = ...
    args: list[AssignName] | None
    defaults: list[NodeNG] | None
    kwonlyargs: list[AssignName]
    posonlyargs: list[AssignName]
    kw_defaults: list[NodeNG | None] | None
    annotations: list[NodeNG | None]
    posonlyargs_annotations: list[NodeNG | None]
    kwonlyargs_annotations: list[NodeNG | None]
    type_comment_args: list[NodeNG | None]
    type_comment_kwonlyargs: list[NodeNG | None]
    type_comment_posonlyargs: list[NodeNG | None]
    varargannotation: NodeNG | None
    kwargannotation: NodeNG | None
    vararg_node: AssignName | None
    kwarg_node: AssignName | None
    def __init__(self, vararg: str | None, kwarg: str | None, parent: NodeNG, vararg_node: AssignName | None = ..., kwarg_node: AssignName | None = ...) -> None:
        """Almost all attributes can be None for living objects where introspection failed."""
        ...
    
    def postinit(self, args: list[AssignName] | None, defaults: list[NodeNG] | None, kwonlyargs: list[AssignName], kw_defaults: list[NodeNG | None] | None, annotations: list[NodeNG | None], posonlyargs: list[AssignName], kwonlyargs_annotations: list[NodeNG | None], posonlyargs_annotations: list[NodeNG | None], varargannotation: NodeNG | None = ..., kwargannotation: NodeNG | None = ..., type_comment_args: list[NodeNG | None] | None = ..., type_comment_kwonlyargs: list[NodeNG | None] | None = ..., type_comment_posonlyargs: list[NodeNG | None] | None = ...) -> None:
        ...
    
    assigned_stmts = ...
    @cached_property
    def fromlineno(self) -> int:
        """The first line that this node appears on in the source code.

        Can also return 0 if the line can not be determined.
        """
        ...
    
    @cached_property
    def arguments(self):
        """Get all the arguments for this node. This includes:
        * Positional only arguments
        * Positional arguments
        * Keyword arguments
        * Variable arguments (.e.g *args)
        * Variable keyword arguments (e.g **kwargs)
        """
        ...
    
    def format_args(self, *, skippable_names: set[str] | None = ...) -> str:
        """Get the arguments formatted as string.

        :returns: The formatted arguments.
        :rtype: str
        """
        ...
    
    def default_value(self, argname):
        """Get the default value for an argument.

        :param argname: The name of the argument to get the default value for.
        :type argname: str

        :raises NoDefault: If there is no default value defined for the
            given argument.
        """
        ...
    
    def is_argument(self, name) -> bool:
        """Check if the given name is defined in the arguments.

        :param name: The name to check for.
        :type name: str

        :returns: Whether the given name is defined in the arguments,
        """
        ...
    
    def find_argname(self, argname, rec=...):
        """Get the index and :class:`AssignName` node for given name.

        :param argname: The name of the argument to search for.
        :type argname: str

        :returns: The index and node for the argument.
        :rtype: tuple(str or None, AssignName or None)
        """
        ...
    
    def get_children(self):
        ...
    


class AssignAttr(_base_nodes.LookupMixIn, _base_nodes.ParentAssignNode):
    """Variation of :class:`ast.Assign` representing assignment to an attribute.

    >>> import astroid
    >>> node = astroid.extract_node('self.attribute = range(10)')
    >>> node
    <Assign l.1 at 0x7effe1d521d0>
    >>> list(node.get_children())
    [<AssignAttr.attribute l.1 at 0x7effe1d52320>, <Call l.1 at 0x7effe1d522e8>]
    >>> list(node.get_children())[0].as_string()
    'self.attribute'
    """
    expr: NodeNG
    _astroid_fields = ...
    _other_fields = ...
    def __init__(self, attrname: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, expr: NodeNG) -> None:
        ...
    
    assigned_stmts = ...
    def get_children(self):
        ...
    
    @decorators.raise_if_nothing_inferred
    @decorators.path_wrapper
    def infer_lhs(self, context: InferenceContext | None = ..., **kwargs: Any) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:
        ...
    


class Assert(_base_nodes.Statement):
    """Class representing an :class:`ast.Assert` node.

    An :class:`Assert` node represents an assert statement.

    >>> import astroid
    >>> node = astroid.extract_node('assert len(things) == 10, "Not enough things"')
    >>> node
    <Assert l.1 at 0x7effe1d527b8>
    """
    _astroid_fields = ...
    test: NodeNG
    fail: NodeNG | None
    def postinit(self, test: NodeNG, fail: NodeNG | None) -> None:
        ...
    
    def get_children(self):
        ...
    


class Assign(_base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Assign` node.

    An :class:`Assign` is a statement where something is explicitly
    asssigned to.

    >>> import astroid
    >>> node = astroid.extract_node('variable = range(10)')
    >>> node
    <Assign l.1 at 0x7effe1db8550>
    """
    targets: list[NodeNG]
    value: NodeNG
    type_annotation: NodeNG | None
    _astroid_fields = ...
    _other_other_fields = ...
    def postinit(self, targets: list[NodeNG], value: NodeNG, type_annotation: NodeNG | None) -> None:
        ...
    
    assigned_stmts = ...
    def get_children(self):
        ...
    


class AnnAssign(_base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing an :class:`ast.AnnAssign` node.

    An :class:`AnnAssign` is an assignment with a type annotation.

    >>> import astroid
    >>> node = astroid.extract_node('variable: List[int] = range(10)')
    >>> node
    <AnnAssign l.1 at 0x7effe1d4c630>
    """
    _astroid_fields = ...
    _other_fields = ...
    target: Name | Attribute | Subscript
    annotation: NodeNG
    value: NodeNG | None
    simple: int
    def postinit(self, target: Name | Attribute | Subscript, annotation: NodeNG, simple: int, value: NodeNG | None) -> None:
        ...
    
    assigned_stmts = ...
    def get_children(self):
        ...
    


class AugAssign(_base_nodes.AssignTypeNode, _base_nodes.OperatorNode, _base_nodes.Statement):
    """Class representing an :class:`ast.AugAssign` node.

    An :class:`AugAssign` is an assignment paired with an operator.

    >>> import astroid
    >>> node = astroid.extract_node('variable += 1')
    >>> node
    <AugAssign l.1 at 0x7effe1db4d68>
    """
    _astroid_fields = ...
    _other_fields = ...
    target: Name | Attribute | Subscript
    value: NodeNG
    def __init__(self, op: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, target: Name | Attribute | Subscript, value: NodeNG) -> None:
        ...
    
    assigned_stmts = ...
    def type_errors(self, context: InferenceContext | None = ...) -> list[util.BadBinaryOperationMessage]:
        """Get a list of type errors which can occur during inference.

        Each TypeError is represented by a :class:`BadBinaryOperationMessage` ,
        which holds the original exception.

        If any inferred result is uninferable, an empty list is returned.
        """
        ...
    
    def get_children(self):
        ...
    


class BinOp(_base_nodes.OperatorNode):
    """Class representing an :class:`ast.BinOp` node.

    A :class:`BinOp` node is an application of a binary operator.

    >>> import astroid
    >>> node = astroid.extract_node('a + b')
    >>> node
    <BinOp l.1 at 0x7f23b2e8cfd0>
    """
    _astroid_fields = ...
    _other_fields = ...
    left: NodeNG
    right: NodeNG
    def __init__(self, op: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, left: NodeNG, right: NodeNG) -> None:
        ...
    
    def type_errors(self, context: InferenceContext | None = ...) -> list[util.BadBinaryOperationMessage]:
        """Get a list of type errors which can occur during inference.

        Each TypeError is represented by a :class:`BadBinaryOperationMessage`,
        which holds the original exception.

        If any inferred result is uninferable, an empty list is returned.
        """
        ...
    
    def get_children(self):
        ...
    
    def op_precedence(self):
        ...
    
    def op_left_associative(self) -> bool:
        ...
    


class BoolOp(NodeNG):
    """Class representing an :class:`ast.BoolOp` node.

    A :class:`BoolOp` is an application of a boolean operator.

    >>> import astroid
    >>> node = astroid.extract_node('a and b')
    >>> node
    <BinOp l.1 at 0x7f23b2e71c50>
    """
    _astroid_fields = ...
    _other_fields = ...
    def __init__(self, op: str, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param op: The operator.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, values: list[NodeNG] | None = ...) -> None:
        """Do some setup after initialisation.

        :param values: The values being applied to the operator.
        """
        ...
    
    def get_children(self):
        ...
    
    def op_precedence(self):
        ...
    


class Break(_base_nodes.NoChildrenNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Break` node.

    >>> import astroid
    >>> node = astroid.extract_node('break')
    >>> node
    <Break l.1 at 0x7f23b2e9e5c0>
    """
    ...


class Call(NodeNG):
    """Class representing an :class:`ast.Call` node.

    A :class:`Call` node is a call to a function, method, etc.

    >>> import astroid
    >>> node = astroid.extract_node('function()')
    >>> node
    <Call l.1 at 0x7f23b2e71eb8>
    """
    _astroid_fields = ...
    func: NodeNG
    args: list[NodeNG]
    keywords: list[Keyword]
    def postinit(self, func: NodeNG, args: list[NodeNG], keywords: list[Keyword]) -> None:
        ...
    
    @property
    def starargs(self) -> list[Starred]:
        """The positional arguments that unpack something."""
        ...
    
    @property
    def kwargs(self) -> list[Keyword]:
        """The keyword arguments that unpack something."""
        ...
    
    def get_children(self):
        ...
    


COMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = ...
UNINFERABLE_OPS = ...
class Compare(NodeNG):
    """Class representing an :class:`ast.Compare` node.

    A :class:`Compare` node indicates a comparison.

    >>> import astroid
    >>> node = astroid.extract_node('a <= b <= c')
    >>> node
    <Compare l.1 at 0x7f23b2e9e6d8>
    >>> node.ops
    [('<=', <Name.b l.1 at 0x7f23b2e9e2b0>), ('<=', <Name.c l.1 at 0x7f23b2e9e390>)]
    """
    _astroid_fields = ...
    left: NodeNG
    ops: list[tuple[str, NodeNG]]
    def postinit(self, left: NodeNG, ops: list[tuple[str, NodeNG]]) -> None:
        ...
    
    def get_children(self):
        """Get the child nodes below this node.

        Overridden to handle the tuple fields and skip returning the operator
        strings.

        :returns: The children.
        :rtype: iterable(NodeNG)
        """
        ...
    
    def last_child(self):
        """An optimized version of list(get_children())[-1]

        :returns: The last child.
        :rtype: NodeNG
        """
        ...
    


class Comprehension(NodeNG):
    """Class representing an :class:`ast.comprehension` node.

    A :class:`Comprehension` indicates the loop inside any type of
    comprehension including generator expressions.

    >>> import astroid
    >>> node = astroid.extract_node('[x for x in some_values]')
    >>> list(node.get_children())
    [<Name.x l.1 at 0x7f23b2e352b0>, <Comprehension l.1 at 0x7f23b2e35320>]
    >>> list(node.get_children())[1].as_string()
    'for x in some_values'
    """
    _astroid_fields = ...
    _other_fields = ...
    optional_assign = ...
    target: NodeNG
    iter: NodeNG
    ifs: list[NodeNG]
    is_async: bool
    def postinit(self, target: NodeNG, iter: NodeNG, ifs: list[NodeNG], is_async: bool) -> None:
        ...
    
    assigned_stmts = ...
    def assign_type(self):
        """The type of assignment that this node performs.

        :returns: The assignment type.
        :rtype: NodeNG
        """
        ...
    
    def get_children(self):
        ...
    


class Const(_base_nodes.NoChildrenNode, Instance):
    """Class representing any constant including num, str, bool, None, bytes.

    >>> import astroid
    >>> node = astroid.extract_node('(5, "This is a string.", True, None, b"bytes")')
    >>> node
    <Tuple.tuple l.1 at 0x7f23b2e358d0>
    >>> list(node.get_children())
    [<Const.int l.1 at 0x7f23b2e35940>,
    <Const.str l.1 at 0x7f23b2e35978>,
    <Const.bool l.1 at 0x7f23b2e359b0>,
    <Const.NoneType l.1 at 0x7f23b2e359e8>,
    <Const.bytes l.1 at 0x7f23b2e35a20>]
    """
    _other_fields = ...
    def __init__(self, value: Any, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., kind: str | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param value: The value that the constant represents.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param kind: The string prefix. "u" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    infer_unary_op = ...
    infer_binary_op = ...
    def __getattr__(self, name):
        ...
    
    def getitem(self, index, context: InferenceContext | None = ...):
        """Get an item from this node if subscriptable.

        :param index: The node to use as a subscript index.
        :type index: Const or Slice

        :raises AstroidTypeError: When the given index cannot be used as a
            subscript index, or if this node is not subscriptable.
        """
        ...
    
    def has_dynamic_getattr(self) -> bool:
        """Check if the node has a custom __getattr__ or __getattribute__.

        :returns: Whether the class has a custom __getattr__ or __getattribute__.
            For a :class:`Const` this is always ``False``.
        """
        ...
    
    def itered(self):
        """An iterator over the elements this node contains.

        :returns: The contents of this node.
        :rtype: iterable(Const)

        :raises TypeError: If this node does not represent something that is iterable.
        """
        ...
    
    def pytype(self) -> str:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...):
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
        :rtype: bool
        """
        ...
    


class Continue(_base_nodes.NoChildrenNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Continue` node.

    >>> import astroid
    >>> node = astroid.extract_node('continue')
    >>> node
    <Continue l.1 at 0x7f23b2e35588>
    """
    ...


class Decorators(NodeNG):
    """A node representing a list of decorators.

    A :class:`Decorators` is the decorators that are applied to
    a method or function.

    >>> import astroid
    >>> node = astroid.extract_node('''
    @property
    def my_property(self):
        return 3
    ''')
    >>> node
    <FunctionDef.my_property l.2 at 0x7f23b2e35d30>
    >>> list(node.get_children())[0]
    <Decorators l.1 at 0x7f23b2e35d68>
    """
    _astroid_fields = ...
    nodes: list[NodeNG]
    def postinit(self, nodes: list[NodeNG]) -> None:
        ...
    
    def scope(self) -> LocalsDictNodeNG:
        """The first parent node defining a new scope.
        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.

        :returns: The first parent scope node.
        """
        ...
    
    def get_children(self):
        ...
    


class DelAttr(_base_nodes.ParentAssignNode):
    """Variation of :class:`ast.Delete` representing deletion of an attribute.

    >>> import astroid
    >>> node = astroid.extract_node('del self.attr')
    >>> node
    <Delete l.1 at 0x7f23b2e35f60>
    >>> list(node.get_children())[0]
    <DelAttr.attr l.1 at 0x7f23b2e411d0>
    """
    _astroid_fields = ...
    _other_fields = ...
    expr: NodeNG
    def __init__(self, attrname: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, expr: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    


class Delete(_base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Delete` node.

    A :class:`Delete` is a ``del`` statement this is deleting something.

    >>> import astroid
    >>> node = astroid.extract_node('del self.attr')
    >>> node
    <Delete l.1 at 0x7f23b2e35f60>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, targets: list[NodeNG]) -> None:
        ...
    
    def get_children(self):
        ...
    


class Dict(NodeNG, Instance):
    """Class representing an :class:`ast.Dict` node.

    A :class:`Dict` is a dictionary that is created with ``{}`` syntax.

    >>> import astroid
    >>> node = astroid.extract_node('{1: "1"}')
    >>> node
    <Dict.dict l.1 at 0x7f23b2e35cc0>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None, col_offset: int | None, parent: NodeNG | None, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, items: list[tuple[InferenceResult, InferenceResult]]) -> None:
        """Do some setup after initialisation.

        :param items: The key-value pairs contained in the dictionary.
        """
        ...
    
    infer_unary_op = ...
    def pytype(self) -> Literal["builtins.dict"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def get_children(self):
        """Get the key and value nodes below this node.

        Children are returned in the order that they are defined in the source
        code, key first then the value.

        :returns: The children.
        :rtype: iterable(NodeNG)
        """
        ...
    
    def last_child(self):
        """An optimized version of list(get_children())[-1]

        :returns: The last child, or None if no children exist.
        :rtype: NodeNG or None
        """
        ...
    
    def itered(self):
        """An iterator over the keys this node contains.

        :returns: The keys of this node.
        :rtype: iterable(NodeNG)
        """
        ...
    
    def getitem(self, index: Const | Slice, context: InferenceContext | None = ...) -> NodeNG:
        """Get an item from this node.

        :param index: The node to use as a subscript index.

        :raises AstroidTypeError: When the given index cannot be used as a
            subscript index, or if this node is not subscriptable.
        :raises AstroidIndexError: If the given index does not exist in the
            dictionary.
        """
        ...
    
    def bool_value(self, context: InferenceContext | None = ...):
        """Determine the boolean value of this node.

        :returns: The boolean value of this node.
        :rtype: bool
        """
        ...
    


class Expr(_base_nodes.Statement):
    """Class representing an :class:`ast.Expr` node.

    An :class:`Expr` is any expression that does not have its value used or
    stored.

    >>> import astroid
    >>> node = astroid.extract_node('method()')
    >>> node
    <Call l.1 at 0x7f23b2e352b0>
    >>> node.parent
    <Expr l.1 at 0x7f23b2e35278>
    """
    _astroid_fields = ...
    value: NodeNG
    def postinit(self, value: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    


class EmptyNode(_base_nodes.NoChildrenNode):
    """Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`."""
    object = ...
    def __init__(self, lineno: None = ..., col_offset: None = ..., parent: None = ..., *, end_lineno: None = ..., end_col_offset: None = ...) -> None:
        ...
    
    def has_underlying_object(self) -> bool:
        ...
    


class ExceptHandler(_base_nodes.MultiLineBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing an :class:`ast.ExceptHandler`. node.

    An :class:`ExceptHandler` is an ``except`` block on a try-except.

    >>> import astroid
    >>> node = astroid.extract_node('''
        try:
            do_something()
        except Exception as error:
            print("Error!")
        ''')
    >>> node
    <Try l.2 at 0x7f23b2e9d908>
    >>> node.handlers
    [<ExceptHandler l.4 at 0x7f23b2e9e860>]
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    type: NodeNG | None
    name: AssignName | None
    body: list[NodeNG]
    assigned_stmts = ...
    def postinit(self, type: NodeNG | None, name: AssignName | None, body: list[NodeNG]) -> None:
        ...
    
    def get_children(self):
        ...
    
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def catch(self, exceptions: list[str] | None) -> bool:
        """Check if this node handles any of the given

        :param exceptions: The names of the exceptions to check for.
        """
        ...
    


class For(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing an :class:`ast.For` node.

    >>> import astroid
    >>> node = astroid.extract_node('for thing in things: print(thing)')
    >>> node
    <For l.1 at 0x7f23b2e8cf28>
    """
    _astroid_fields = ...
    _other_other_fields = ...
    _multi_line_block_fields = ...
    optional_assign = ...
    target: NodeNG
    iter: NodeNG
    body: list[NodeNG]
    orelse: list[NodeNG]
    type_annotation: NodeNG | None
    def postinit(self, target: NodeNG, iter: NodeNG, body: list[NodeNG], orelse: list[NodeNG], type_annotation: NodeNG | None) -> None:
        ...
    
    assigned_stmts = ...
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def get_children(self):
        ...
    


class AsyncFor(For):
    """Class representing an :class:`ast.AsyncFor` node.

    An :class:`AsyncFor` is an asynchronous :class:`For` built with
    the ``async`` keyword.

    >>> import astroid
    >>> node = astroid.extract_node('''
    async def func(things):
        async for thing in things:
            print(thing)
    ''')
    >>> node
    <AsyncFunctionDef.func l.2 at 0x7f23b2e416d8>
    >>> node.body[0]
    <AsyncFor l.3 at 0x7f23b2e417b8>
    """
    ...


class Await(NodeNG):
    """Class representing an :class:`ast.Await` node.

    An :class:`Await` is the ``await`` keyword.

    >>> import astroid
    >>> node = astroid.extract_node('''
    async def func(things):
        await other_func()
    ''')
    >>> node
    <AsyncFunctionDef.func l.2 at 0x7f23b2e41748>
    >>> node.body[0]
    <Expr l.3 at 0x7f23b2e419e8>
    >>> list(node.body[0].get_children())[0]
    <Await l.3 at 0x7f23b2e41a20>
    """
    _astroid_fields = ...
    value: NodeNG
    def postinit(self, value: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    


class ImportFrom(_base_nodes.ImportNode):
    """Class representing an :class:`ast.ImportFrom` node.

    >>> import astroid
    >>> node = astroid.extract_node('from my_package import my_module')
    >>> node
    <ImportFrom l.1 at 0x7f23b2e415c0>
    """
    _other_fields = ...
    def __init__(self, fromname: str | None, names: list[tuple[str, str | None]], level: int | None = ..., lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param fromname: The module that is being imported from.

        :param names: What is being imported from the module.

        :param level: The level of relative import.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    


class Attribute(NodeNG):
    """Class representing an :class:`ast.Attribute` node."""
    expr: NodeNG
    _astroid_fields = ...
    _other_fields = ...
    def __init__(self, attrname: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, expr: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    


class Global(_base_nodes.NoChildrenNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Global` node.

    >>> import astroid
    >>> node = astroid.extract_node('global a_global')
    >>> node
    <Global l.1 at 0x7f23b2e9de10>
    """
    _other_fields = ...
    def __init__(self, names: list[str], lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param names: The names being declared as global.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    


class If(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):
    """Class representing an :class:`ast.If` node.

    >>> import astroid
    >>> node = astroid.extract_node('if condition: print(True)')
    >>> node
    <If l.1 at 0x7f23b2e9dd30>
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    test: NodeNG
    body: list[NodeNG]
    orelse: list[NodeNG]
    def postinit(self, test: NodeNG, body: list[NodeNG], orelse: list[NodeNG]) -> None:
        ...
    
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from the given line number to where this node ends.

        :param lineno: The line number to start the range at.

        :returns: The range of line numbers that this node belongs to,
            starting at the given line number.
        """
        ...
    
    def get_children(self):
        ...
    
    def has_elif_block(self):
        ...
    


class IfExp(NodeNG):
    """Class representing an :class:`ast.IfExp` node.
    >>> import astroid
    >>> node = astroid.extract_node('value if condition else other')
    >>> node
    <IfExp l.1 at 0x7f23b2e9dbe0>
    """
    _astroid_fields = ...
    test: NodeNG
    body: NodeNG
    orelse: NodeNG
    def postinit(self, test: NodeNG, body: NodeNG, orelse: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    
    def op_left_associative(self) -> Literal[False]:
        ...
    


class Import(_base_nodes.ImportNode):
    """Class representing an :class:`ast.Import` node.
    >>> import astroid
    >>> node = astroid.extract_node('import astroid')
    >>> node
    <Import l.1 at 0x7f23b2e4e5c0>
    """
    _other_fields = ...
    def __init__(self, names: list[tuple[str, str | None]], lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param names: The names being imported.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    


class Keyword(NodeNG):
    """Class representing an :class:`ast.keyword` node.

    >>> import astroid
    >>> node = astroid.extract_node('function(a_kwarg=True)')
    >>> node
    <Call l.1 at 0x7f23b2e9e320>
    >>> node.keywords
    [<Keyword l.1 at 0x7f23b2e9e9b0>]
    """
    _astroid_fields = ...
    _other_fields = ...
    value: NodeNG
    def __init__(self, arg: str | None, lineno: int | None, col_offset: int | None, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, value: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    


class List(BaseContainer):
    """Class representing an :class:`ast.List` node.

    >>> import astroid
    >>> node = astroid.extract_node('[1, 2, 3]')
    >>> node
    <List.list l.1 at 0x7f23b2e9e128>
    """
    _other_fields = ...
    def __init__(self, ctx: Context | None = ..., lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param ctx: Whether the list is assigned to or loaded from.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    assigned_stmts = ...
    infer_unary_op = ...
    infer_binary_op = ...
    def pytype(self) -> Literal["builtins.list"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def getitem(self, index, context: InferenceContext | None = ...):
        """Get an item from this node.

        :param index: The node to use as a subscript index.
        :type index: Const or Slice
        """
        ...
    


class Nonlocal(_base_nodes.NoChildrenNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Nonlocal` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    def function():
        nonlocal var
    ''')
    >>> node
    <FunctionDef.function l.2 at 0x7f23b2e9e208>
    >>> node.body[0]
    <Nonlocal l.3 at 0x7f23b2e9e908>
    """
    _other_fields = ...
    def __init__(self, names: list[str], lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param names: The names being declared as not local.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    


class ParamSpec(_base_nodes.AssignTypeNode):
    """Class representing a :class:`ast.ParamSpec` node.

    >>> import astroid
    >>> node = astroid.extract_node('type Alias[**P] = Callable[P, int]')
    >>> node.type_params[0]
    <ParamSpec l.1 at 0x7f23b2e4e198>
    """
    _astroid_fields = ...
    name: AssignName
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int, end_col_offset: int) -> None:
        ...
    
    def postinit(self, *, name: AssignName) -> None:
        ...
    
    assigned_stmts = ...


class Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):
    """Class representing an :class:`ast.Pass` node.

    >>> import astroid
    >>> node = astroid.extract_node('pass')
    >>> node
    <Pass l.1 at 0x7f23b2e9e748>
    """
    ...


class Raise(_base_nodes.Statement):
    """Class representing an :class:`ast.Raise` node.

    >>> import astroid
    >>> node = astroid.extract_node('raise RuntimeError("Something bad happened!")')
    >>> node
    <Raise l.1 at 0x7f23b2e9e828>
    """
    _astroid_fields = ...
    exc: NodeNG | None
    cause: NodeNG | None
    def postinit(self, exc: NodeNG | None, cause: NodeNG | None) -> None:
        ...
    
    def raises_not_implemented(self) -> bool:
        """Check if this node raises a :class:`NotImplementedError`.

        :returns: Whether this node raises a :class:`NotImplementedError`.
        """
        ...
    
    def get_children(self):
        ...
    


class Return(_base_nodes.Statement):
    """Class representing an :class:`ast.Return` node.

    >>> import astroid
    >>> node = astroid.extract_node('return True')
    >>> node
    <Return l.1 at 0x7f23b8211908>
    """
    _astroid_fields = ...
    value: NodeNG | None
    def postinit(self, value: NodeNG | None) -> None:
        ...
    
    def get_children(self):
        ...
    
    def is_tuple_return(self):
        ...
    


class Set(BaseContainer):
    """Class representing an :class:`ast.Set` node.

    >>> import astroid
    >>> node = astroid.extract_node('{1, 2, 3}')
    >>> node
    <Set.set l.1 at 0x7f23b2e71d68>
    """
    infer_unary_op = ...
    def pytype(self) -> Literal["builtins.set"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    


class Slice(NodeNG):
    """Class representing an :class:`ast.Slice` node.

    >>> import astroid
    >>> node = astroid.extract_node('things[1:3]')
    >>> node
    <Subscript l.1 at 0x7f23b2e71f60>
    >>> node.slice
    <Slice l.1 at 0x7f23b2e71e80>
    """
    _astroid_fields = ...
    lower: NodeNG | None
    upper: NodeNG | None
    step: NodeNG | None
    def postinit(self, lower: NodeNG | None, upper: NodeNG | None, step: NodeNG | None) -> None:
        ...
    
    def pytype(self) -> Literal["builtins.slice"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def display_type(self) -> Literal["Slice"]:
        """A human readable type of this node.

        :returns: The type of this node.
        """
        ...
    
    def igetattr(self, attrname: str, context: InferenceContext | None = ...) -> Iterator[SuccessfulInferenceResult]:
        """Infer the possible values of the given attribute on the slice.

        :param attrname: The name of the attribute to infer.

        :returns: The inferred possible values.
        """
        ...
    
    def getattr(self, attrname, context: InferenceContext | None = ...):
        ...
    
    def get_children(self):
        ...
    


class Starred(_base_nodes.ParentAssignNode):
    """Class representing an :class:`ast.Starred` node.

    >>> import astroid
    >>> node = astroid.extract_node('*args')
    >>> node
    <Starred l.1 at 0x7f23b2e41978>
    """
    _astroid_fields = ...
    _other_fields = ...
    value: NodeNG
    def __init__(self, ctx: Context, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, value: NodeNG) -> None:
        ...
    
    assigned_stmts = ...
    def get_children(self):
        ...
    


class Subscript(NodeNG):
    """Class representing an :class:`ast.Subscript` node.

    >>> import astroid
    >>> node = astroid.extract_node('things[1:3]')
    >>> node
    <Subscript l.1 at 0x7f23b2e71f60>
    """
    _SUBSCRIPT_SENTINEL = ...
    _astroid_fields = ...
    _other_fields = ...
    value: NodeNG
    slice: NodeNG
    def __init__(self, ctx: Context, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, value: NodeNG, slice: NodeNG) -> None:
        ...
    
    def get_children(self):
        ...
    
    @decorators.raise_if_nothing_inferred
    def infer_lhs(self, context: InferenceContext | None = ..., **kwargs: Any):
        ...
    


class Try(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):
    """Class representing a :class:`ast.Try` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
        try:
            do_something()
        except Exception as error:
            print("Error!")
        finally:
            print("Cleanup!")
        ''')
    >>> node
    <Try l.2 at 0x7f23b2e41d68>
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    def __init__(self, *, lineno: int, col_offset: int, end_lineno: int, end_col_offset: int, parent: NodeNG) -> None:
        """
        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, *, body: list[NodeNG], handlers: list[ExceptHandler], orelse: list[NodeNG], finalbody: list[NodeNG]) -> None:
        """Do some setup after initialisation.

        :param body: The contents of the block to catch exceptions from.

        :param handlers: The exception handlers.

        :param orelse: The contents of the ``else`` block.

        :param finalbody: The contents of the ``finally`` block.
        """
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from a given line number to where this node ends."""
        ...
    
    def get_children(self):
        ...
    


class TryStar(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):
    """Class representing an :class:`ast.TryStar` node."""
    _astroid_fields = ...
    _multi_line_block_fields = ...
    def __init__(self, *, lineno: int | None = ..., col_offset: int | None = ..., end_lineno: int | None = ..., end_col_offset: int | None = ..., parent: NodeNG | None = ...) -> None:
        """
        :param lineno: The line that this node appears on in the source code.
        :param col_offset: The column that this node appears on in the
            source code.
        :param parent: The parent node in the syntax tree.
        :param end_lineno: The last line this node appears on in the source code.
        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, *, body: list[NodeNG] | None = ..., handlers: list[ExceptHandler] | None = ..., orelse: list[NodeNG] | None = ..., finalbody: list[NodeNG] | None = ...) -> None:
        """Do some setup after initialisation.
        :param body: The contents of the block to catch exceptions from.
        :param handlers: The exception handlers.
        :param orelse: The contents of the ``else`` block.
        :param finalbody: The contents of the ``finally`` block.
        """
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from a given line number to where this node ends."""
        ...
    
    def get_children(self):
        ...
    


class Tuple(BaseContainer):
    """Class representing an :class:`ast.Tuple` node.

    >>> import astroid
    >>> node = astroid.extract_node('(1, 2, 3)')
    >>> node
    <Tuple.tuple l.1 at 0x7f23b2e41780>
    """
    _other_fields = ...
    def __init__(self, ctx: Context | None = ..., lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param ctx: Whether the tuple is assigned to or loaded from.

        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    assigned_stmts = ...
    infer_unary_op = ...
    infer_binary_op = ...
    def pytype(self) -> Literal["builtins.tuple"]:
        """Get the name of the type that this node represents.

        :returns: The name of the type.
        """
        ...
    
    def getitem(self, index, context: InferenceContext | None = ...):
        """Get an item from this node.

        :param index: The node to use as a subscript index.
        :type index: Const or Slice
        """
        ...
    


class TypeAlias(_base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing a :class:`ast.TypeAlias` node.

    >>> import astroid
    >>> node = astroid.extract_node('type Point = tuple[float, float]')
    >>> node
    <TypeAlias l.1 at 0x7f23b2e4e198>
    """
    _astroid_fields = ...
    name: AssignName
    type_params: list[TypeVar | ParamSpec | TypeVarTuple]
    value: NodeNG
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int, end_col_offset: int) -> None:
        ...
    
    def postinit(self, *, name: AssignName, type_params: list[TypeVar | ParamSpec | TypeVarTuple], value: NodeNG) -> None:
        ...
    
    assigned_stmts: ClassVar[Callable[[TypeAlias, AssignName, InferenceContext | None, None], Generator[NodeNG],]] = ...


class TypeVar(_base_nodes.AssignTypeNode):
    """Class representing a :class:`ast.TypeVar` node.

    >>> import astroid
    >>> node = astroid.extract_node('type Point[T] = tuple[float, float]')
    >>> node.type_params[0]
    <TypeVar l.1 at 0x7f23b2e4e198>
    """
    _astroid_fields = ...
    name: AssignName
    bound: NodeNG | None
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int, end_col_offset: int) -> None:
        ...
    
    def postinit(self, *, name: AssignName, bound: NodeNG | None) -> None:
        ...
    
    assigned_stmts = ...


class TypeVarTuple(_base_nodes.AssignTypeNode):
    """Class representing a :class:`ast.TypeVarTuple` node.

    >>> import astroid
    >>> node = astroid.extract_node('type Alias[*Ts] = tuple[*Ts]')
    >>> node.type_params[0]
    <TypeVarTuple l.1 at 0x7f23b2e4e198>
    """
    _astroid_fields = ...
    name: AssignName
    def __init__(self, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int, end_col_offset: int) -> None:
        ...
    
    def postinit(self, *, name: AssignName) -> None:
        ...
    
    assigned_stmts = ...


UNARY_OP_METHOD = ...
class UnaryOp(_base_nodes.OperatorNode):
    """Class representing an :class:`ast.UnaryOp` node.

    >>> import astroid
    >>> node = astroid.extract_node('-5')
    >>> node
    <UnaryOp l.1 at 0x7f23b2e4e198>
    """
    _astroid_fields = ...
    _other_fields = ...
    operand: NodeNG
    def __init__(self, op: str, lineno: int, col_offset: int, parent: NodeNG, *, end_lineno: int | None, end_col_offset: int | None) -> None:
        ...
    
    def postinit(self, operand: NodeNG) -> None:
        ...
    
    def type_errors(self, context: InferenceContext | None = ...) -> list[util.BadUnaryOperationMessage]:
        """Get a list of type errors which can occur during inference.

        Each TypeError is represented by a :class:`BadUnaryOperationMessage`,
        which holds the original exception.

        If any inferred result is uninferable, an empty list is returned.
        """
        ...
    
    def get_children(self):
        ...
    
    def op_precedence(self):
        ...
    


class While(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):
    """Class representing an :class:`ast.While` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    while condition():
        print("True")
    ''')
    >>> node
    <While l.2 at 0x7f23b2e4e390>
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    test: NodeNG
    body: list[NodeNG]
    orelse: list[NodeNG]
    def postinit(self, test: NodeNG, body: list[NodeNG], orelse: list[NodeNG]) -> None:
        ...
    
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def block_range(self, lineno: int) -> tuple[int, int]:
        """Get a range from the given line number to where this node ends.

        :param lineno: The line number to start the range at.

        :returns: The range of line numbers that this node belongs to,
            starting at the given line number.
        """
        ...
    
    def get_children(self):
        ...
    


class With(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement):
    """Class representing an :class:`ast.With` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    with open(file_path) as file_:
        print(file_.read())
    ''')
    >>> node
    <With l.2 at 0x7f23b2e4e710>
    """
    _astroid_fields = ...
    _other_other_fields = ...
    _multi_line_block_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, items: list[tuple[NodeNG, NodeNG | None]] | None = ..., body: list[NodeNG] | None = ..., type_annotation: NodeNG | None = ...) -> None:
        """Do some setup after initialisation.

        :param items: The pairs of context managers and the names
            they are assigned to.

        :param body: The contents of the ``with`` block.
        """
        ...
    
    assigned_stmts = ...
    @cached_property
    def blockstart_tolineno(self):
        """The line on which the beginning of this block ends.

        :type: int
        """
        ...
    
    def get_children(self):
        """Get the child nodes below this node.

        :returns: The children.
        :rtype: iterable(NodeNG)
        """
        ...
    


class AsyncWith(With):
    """Asynchronous ``with`` built with the ``async`` keyword."""
    ...


class Yield(NodeNG):
    """Class representing an :class:`ast.Yield` node.

    >>> import astroid
    >>> node = astroid.extract_node('yield True')
    >>> node
    <Yield l.1 at 0x7f23b2e4e5f8>
    """
    _astroid_fields = ...
    value: NodeNG | None
    def postinit(self, value: NodeNG | None) -> None:
        ...
    
    def get_children(self):
        ...
    


class YieldFrom(Yield):
    """Class representing an :class:`ast.YieldFrom` node."""
    ...


class DictUnpack(_base_nodes.NoChildrenNode):
    """Represents the unpacking of dicts into dicts using :pep:`448`."""
    ...


class FormattedValue(NodeNG):
    """Class representing an :class:`ast.FormattedValue` node.

    Represents a :pep:`498` format string.

    >>> import astroid
    >>> node = astroid.extract_node('f"Format {type_}"')
    >>> node
    <JoinedStr l.1 at 0x7f23b2e4ed30>
    >>> node.values
    [<Const.str l.1 at 0x7f23b2e4eda0>, <FormattedValue l.1 at 0x7f23b2e4edd8>]
    """
    _astroid_fields = ...
    _other_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, *, value: NodeNG, conversion: int, format_spec: JoinedStr | None = ...) -> None:
        """Do some setup after initialisation.

        :param value: The value to be formatted into the string.

        :param conversion: The type of formatting to be applied to the value.

        :param format_spec: The formatting to be applied to the value.
        :type format_spec: JoinedStr or None
        """
        ...
    
    def get_children(self):
        ...
    


MISSING_VALUE = ...
class JoinedStr(NodeNG):
    """Represents a list of string expressions to be joined.

    >>> import astroid
    >>> node = astroid.extract_node('f"Format {type_}"')
    >>> node
    <JoinedStr l.1 at 0x7f23b2e4ed30>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, values: list[NodeNG] | None = ...) -> None:
        """Do some setup after initialisation.

        :param value: The string expressions to be joined.

        :type: list(FormattedValue or Const)
        """
        ...
    
    def get_children(self):
        ...
    


class NamedExpr(_base_nodes.AssignTypeNode):
    """Represents the assignment from the assignment expression

    >>> import astroid
    >>> module = astroid.parse('if a := 1: pass')
    >>> module.body[0].test
    <NamedExpr l.1 at 0x7f23b2e4ed30>
    """
    _astroid_fields = ...
    optional_assign = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        """
        :param lineno: The line that this node appears on in the source code.

        :param col_offset: The column that this node appears on in the
            source code.

        :param parent: The parent node in the syntax tree.

        :param end_lineno: The last line this node appears on in the source code.

        :param end_col_offset: The end column this node appears on in the
            source code. Note: This is after the last symbol.
        """
        ...
    
    def postinit(self, target: NodeNG, value: NodeNG) -> None:
        ...
    
    assigned_stmts = ...
    def frame(self, *, future: Literal[None, True] = ...) -> nodes.FunctionDef | nodes.Module | nodes.ClassDef | nodes.Lambda:
        """The first parent frame node.

        A frame node is a :class:`Module`, :class:`FunctionDef`,
        or :class:`ClassDef`.

        :returns: The first parent frame node.
        """
        ...
    
    def scope(self) -> LocalsDictNodeNG:
        """The first parent node defining a new scope.
        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.

        :returns: The first parent scope node.
        """
        ...
    
    def set_local(self, name: str, stmt: NodeNG) -> None:
        """Define that the given name is declared in the given statement node.
        NamedExpr's in Arguments, Keyword or Comprehension are evaluated in their
        parent's parent scope. So we add to their frame's locals.

        .. seealso:: :meth:`scope`

        :param name: The name that is being defined.

        :param stmt: The statement that defines the given name.
        """
        ...
    


class Unknown(_base_nodes.AssignTypeNode):
    """This node represents a node in a constructed AST where
    introspection is not possible.  At the moment, it's only used in
    the args attribute of FunctionDef nodes where function signature
    introspection failed.
    """
    name = ...
    def __init__(self, lineno: None = ..., col_offset: None = ..., parent: None = ..., *, end_lineno: None = ..., end_col_offset: None = ...) -> None:
        ...
    
    def qname(self) -> Literal["Unknown"]:
        ...
    


class EvaluatedObject(NodeNG):
    """Contains an object that has already been inferred

    This class is useful to pre-evaluate a particular node,
    with the resulting class acting as the non-evaluated node.
    """
    name = ...
    _astroid_fields = ...
    _other_fields = ...
    def __init__(self, original: SuccessfulInferenceResult, value: InferenceResult) -> None:
        ...
    


class Match(_base_nodes.Statement, _base_nodes.MultiLineBlockNode):
    """Class representing a :class:`ast.Match` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case 200:
            ...
        case _:
            ...
    ''')
    >>> node
    <Match l.2 at 0x10c24e170>
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, subject: NodeNG, cases: list[MatchCase]) -> None:
        ...
    


class Pattern(NodeNG):
    """Base class for all Pattern nodes."""
    ...


class MatchCase(_base_nodes.MultiLineBlockNode):
    """Class representing a :class:`ast.match_case` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case 200:
            ...
    ''')
    >>> node.cases[0]
    <MatchCase l.3 at 0x10c24e590>
    """
    _astroid_fields = ...
    _multi_line_block_fields = ...
    lineno: None
    col_offset: None
    end_lineno: None
    end_col_offset: None
    def __init__(self, *, parent: NodeNG | None = ...) -> None:
        ...
    
    def postinit(self, *, pattern: Pattern, guard: NodeNG | None, body: list[NodeNG]) -> None:
        ...
    


class MatchValue(Pattern):
    """Class representing a :class:`ast.MatchValue` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case 200:
            ...
    ''')
    >>> node.cases[0].pattern
    <MatchValue l.3 at 0x10c24e200>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, value: NodeNG) -> None:
        ...
    


class MatchSingleton(Pattern):
    """Class representing a :class:`ast.MatchSingleton` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case True:
            ...
        case False:
            ...
        case None:
            ...
    ''')
    >>> node.cases[0].pattern
    <MatchSingleton l.3 at 0x10c2282e0>
    >>> node.cases[1].pattern
    <MatchSingleton l.5 at 0x10c228af0>
    >>> node.cases[2].pattern
    <MatchSingleton l.7 at 0x10c229f90>
    """
    _other_fields = ...
    def __init__(self, *, value: Literal[True, False, None], lineno: int | None = ..., col_offset: int | None = ..., end_lineno: int | None = ..., end_col_offset: int | None = ..., parent: NodeNG | None = ...) -> None:
        ...
    


class MatchSequence(Pattern):
    """Class representing a :class:`ast.MatchSequence` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case [1, 2]:
            ...
        case (1, 2, *_):
            ...
    ''')
    >>> node.cases[0].pattern
    <MatchSequence l.3 at 0x10ca80d00>
    >>> node.cases[1].pattern
    <MatchSequence l.5 at 0x10ca80b20>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, patterns: list[Pattern]) -> None:
        ...
    


class MatchMapping(_base_nodes.AssignTypeNode, Pattern):
    """Class representing a :class:`ast.MatchMapping` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case {1: "Hello", 2: "World", 3: _, **rest}:
            ...
    ''')
    >>> node.cases[0].pattern
    <MatchMapping l.3 at 0x10c8a8850>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, keys: list[NodeNG], patterns: list[Pattern], rest: AssignName | None) -> None:
        ...
    
    assigned_stmts = ...


class MatchClass(Pattern):
    """Class representing a :class:`ast.MatchClass` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case Point2D(0, 0):
            ...
        case Point3D(x=0, y=0, z=0):
            ...
    ''')
    >>> node.cases[0].pattern
    <MatchClass l.3 at 0x10ca83940>
    >>> node.cases[1].pattern
    <MatchClass l.5 at 0x10ca80880>
    """
    _astroid_fields = ...
    _other_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, cls: NodeNG, patterns: list[Pattern], kwd_attrs: list[str], kwd_patterns: list[Pattern]) -> None:
        ...
    


class MatchStar(_base_nodes.AssignTypeNode, Pattern):
    """Class representing a :class:`ast.MatchStar` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case [1, *_]:
            ...
    ''')
    >>> node.cases[0].pattern.patterns[1]
    <MatchStar l.3 at 0x10ca809a0>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, name: AssignName | None) -> None:
        ...
    
    assigned_stmts = ...


class MatchAs(_base_nodes.AssignTypeNode, Pattern):
    """Class representing a :class:`ast.MatchAs` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case [1, a]:
            ...
        case {'key': b}:
            ...
        case Point2D(0, 0) as c:
            ...
        case d:
            ...
    ''')
    >>> node.cases[0].pattern.patterns[1]
    <MatchAs l.3 at 0x10d0b2da0>
    >>> node.cases[1].pattern.patterns[0]
    <MatchAs l.5 at 0x10d0b2920>
    >>> node.cases[2].pattern
    <MatchAs l.7 at 0x10d0b06a0>
    >>> node.cases[3].pattern
    <MatchAs l.9 at 0x10d09b880>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, pattern: Pattern | None, name: AssignName | None) -> None:
        ...
    
    assigned_stmts = ...


class MatchOr(Pattern):
    """Class representing a :class:`ast.MatchOr` node.

    >>> import astroid
    >>> node = astroid.extract_node('''
    match x:
        case 400 | 401 | 402:
            ...
    ''')
    >>> node.cases[0].pattern
    <MatchOr l.3 at 0x10d0b0b50>
    """
    _astroid_fields = ...
    def __init__(self, lineno: int | None = ..., col_offset: int | None = ..., parent: NodeNG | None = ..., *, end_lineno: int | None = ..., end_col_offset: int | None = ...) -> None:
        ...
    
    def postinit(self, *, patterns: list[Pattern]) -> None:
        ...
    


CONST_CLS: dict[type, type[NodeNG]] = ...
def const_factory(value: Any) -> ConstFactoryResult:
    """Return an astroid node for a python value."""
    ...

