"""
This type stub file was generated by pyright.
"""

import os
import sys
import types
from collections.abc import Callable, Iterable, Sequence
from astroid.const import PY310_PLUS
from astroid.interpreter._import import spec

"""Python modules manipulation utility functions.

:type PY_SOURCE_EXTS: tuple(str)
:var PY_SOURCE_EXTS: list of possible python source file extension

:type STD_LIB_DIRS: set of str
:var STD_LIB_DIRS: directories where standard modules are located

:type BUILTIN_MODULES: dict
:var BUILTIN_MODULES: dictionary with builtin module names has key
"""
if PY310_PLUS:
    ...
else:
    ...
logger = ...
if sys.platform.startswith("win"):
    PY_SOURCE_EXTS = ...
    PY_SOURCE_EXTS_STUBS_FIRST = ...
    PY_COMPILED_EXTS = ...
else:
    PY_SOURCE_EXTS = ...
    PY_SOURCE_EXTS_STUBS_FIRST = ...
    PY_COMPILED_EXTS = ...
STD_LIB_DIRS = ...
if os.name == "nt":
    ...
if os.name == "posix":
    prefix: str = ...
EXT_LIB_DIRS = ...
BUILTIN_MODULES = ...
class NoSourceFile(Exception):
    """Exception raised when we are not able to get a python
    source file for a precompiled file.
    """
    ...


def load_module_from_name(dotted_name: str) -> types.ModuleType:
    """Load a Python module from its name.

    :type dotted_name: str
    :param dotted_name: python name of a module or package

    :raise ImportError: if the module or package is not found

    :rtype: module
    :return: the loaded module
    """
    ...

def load_module_from_modpath(parts: Sequence[str]) -> types.ModuleType:
    """Load a python module from its split name.

    :param parts:
      python name of a module or package split on '.'

    :raise ImportError: if the module or package is not found

    :return: the loaded module
    """
    ...

def load_module_from_file(filepath: str) -> types.ModuleType:
    """Load a Python module from it's path.

    :type filepath: str
    :param filepath: path to the python module or package

    :raise ImportError: if the module or package is not found

    :rtype: module
    :return: the loaded module
    """
    ...

def check_modpath_has_init(path: str, mod_path: list[str]) -> bool:
    """Check there are some __init__.py all along the way."""
    ...

def modpath_from_file_with_callback(filename: str, path: Sequence[str] | None = ..., is_package_cb: Callable[[str, list[str]], bool] | None = ...) -> list[str]:
    ...

def modpath_from_file(filename: str, path: Sequence[str] | None = ...) -> list[str]:
    """Get the corresponding split module's name from a filename.

    This function will return the name of a module or package split on `.`.

    :type filename: str
    :param filename: file's path for which we want the module's name

    :type Optional[List[str]] path:
      Optional list of path where the module or package should be
      searched (use sys.path if nothing or None is given)

    :raise ImportError:
      if the corresponding module's name has not been found

    :rtype: list(str)
    :return: the corresponding split module's name
    """
    ...

def file_from_modpath(modpath: list[str], path: Sequence[str] | None = ..., context_file: str | None = ...) -> str | None:
    ...

def file_info_from_modpath(modpath: list[str], path: Sequence[str] | None = ..., context_file: str | None = ...) -> spec.ModuleSpec:
    """Given a mod path (i.e. split module / package name), return the
    corresponding file.

    Giving priority to source file over precompiled file if it exists.

    :param modpath:
      split module's name (i.e name of a module or package split
      on '.')
      (this means explicit relative imports that start with dots have
      empty strings in this list!)

    :param path:
      optional list of path where the module or package should be
      searched (use sys.path if nothing or None is given)

    :param context_file:
      context file to consider, necessary if the identifier has been
      introduced using a relative import unresolvable in the actual
      context (i.e. modutils)

    :raise ImportError: if there is no such module in the directory

    :return:
      the path to the module's file or None if it's an integrated
      builtin module such as 'sys'
    """
    ...

def get_module_part(dotted_name: str, context_file: str | None = ...) -> str:
    """Given a dotted name return the module part of the name :

    >>> get_module_part('astroid.as_string.dump')
    'astroid.as_string'

    :param dotted_name: full name of the identifier we are interested in

    :param context_file:
      context file to consider, necessary if the identifier has been
      introduced using a relative import unresolvable in the actual
      context (i.e. modutils)

    :raise ImportError: if there is no such module in the directory

    :return:
      the module part of the name or None if we have not been able at
      all to import the given name

    XXX: deprecated, since it doesn't handle package precedence over module
    (see #10066)
    """
    ...

def get_module_files(src_directory: str, blacklist: Sequence[str], list_all: bool = ...) -> list[str]:
    """Given a package directory return a list of all available python
    module's files in the package and its subpackages.

    :param src_directory:
      path of the directory corresponding to the package

    :param blacklist: iterable
      list of files or directories to ignore.

    :param list_all:
        get files from all paths, including ones without __init__.py

    :return:
      the list of all available python module's files in the package and
      its subpackages
    """
    ...

def get_source_file(filename: str, include_no_ext: bool = ..., prefer_stubs: bool = ...) -> str:
    """Given a python module's file name return the matching source file
    name (the filename will be returned identically if it's already an
    absolute path to a python source file).

    :param filename: python module's file name

    :raise NoSourceFile: if no source file exists on the file system

    :return: the absolute path of the source file if it exists
    """
    ...

def is_python_source(filename: str | None) -> bool:
    """Return: True if the filename is a python source file."""
    ...

def is_stdlib_module(modname: str) -> bool:
    """Return: True if the modname is in the standard library"""
    ...

def module_in_path(modname: str, path: str | Iterable[str]) -> bool:
    """Try to determine if a module is imported from one of the specified paths

    :param modname: name of the module

    :param path: paths to consider

    :return:
      true if the module:
      - is located on the path listed in one of the directory in `paths`
    """
    ...

def is_standard_module(modname: str, std_path: Iterable[str] | None = ...) -> bool:
    """Try to guess if a module is a standard python module (by default,
    see `std_path` parameter's description).

    :param modname: name of the module we are interested in

    :param std_path: list of path considered has standard

    :return:
      true if the module:
      - is located on the path listed in one of the directory in `std_path`
      - is a built-in module
    """
    ...

def is_relative(modname: str, from_file: str) -> bool:
    """Return true if the given module name is relative to the given
    file name.

    :param modname: name of the module we are interested in

    :param from_file:
      path of the module from which modname has been imported

    :return:
      true if the module has been imported relatively to `from_file`
    """
    ...

def is_namespace(specobj: spec.ModuleSpec) -> bool:
    ...

def is_directory(specobj: spec.ModuleSpec) -> bool:
    ...

def is_module_name_part_of_extension_package_whitelist(module_name: str, package_whitelist: set[str]) -> bool:
    """
    Returns True if one part of the module name is in the package whitelist.

    >>> is_module_name_part_of_extension_package_whitelist('numpy.core.umath', {'numpy'})
    True
    """
    ...
