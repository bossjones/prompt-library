<?xml version="1.0" encoding="UTF-8"?>
<cursorrules>
  <purpose>
    You are an AI assistant responsible for helping a developer create a LLM prompt library and maintain Python code quality.
  </purpose>

  <instructions>
    <instruction>Create a main folder called `prompt-library` to house all prompts.</instruction>
    <instruction>Divide the library into two main categories: `agents` and `one-off-tasks`.</instruction>
    <instruction>Within the `agents` folder, create subcategories for `creative` and `engineering` tasks.</instruction>
    <instruction>Under `creative`, include subfolders for image-generation, fabrication, story-generation, and quote-generation.</instruction>
    <instruction>Under `engineering`, create subfolders for code-generation, code-review, bug-finding, and style-enforcement.</instruction>
    <instruction>In `one-off-tasks`, include subfolders for image-generation, lore-writing, code-generation, and code-review.</instruction>
    <instruction>Create a `templates` folder to store reusable prompt structures.</instruction>
    <instruction>Include a comprehensive README.md file at the root level.</instruction>
  </instructions>

  <python_standards>
    <project_structure>
      <standard>Maintain clear project structure with separate directories for source code, tests (`tests/`), and documentation (`docs/`).</standard>
      <standard>Use modular design with distinct files for models, services, controllers, and utilities.</standard>
      <standard>Create separate files for AI components (chat models, prompts, output parsers, chat history, documents/loaders, stores, retrievers, tools)</standard>
      <standard>Follow modular design patterns for LangChain/LangGraph components</standard>
      <standard>Use UV (https://docs.astral.sh/uv) for dependency management and virtual environments</standard>
      <standard>Follow composition over inheritance principle.</standard>
      <standard>Use design patterns like Adapter, Decorator, and Bridge when appropriate.</standard>
    </project_structure>

    <code_quality>
      <standard>Add typing annotations to ALL functions and classes with return types.</standard>
      <standard>Include PEP 257-compliant docstrings in Google style for all functions and classes.</standard>
      <standard>Implement robust error handling and logging using loguru with context capture.</standard>
      <standard>Use descriptive variable and function names.</standard>
      <standard>Add detailed comments for complex logic.</standard>
      <standard>Provide rich error context for debugging.</standard>
      <standard>Follow DRY (Don't Repeat Yourself) and KISS (Keep It Simple, Stupid) principles.</standard>
      <standard>Skip type annotations and docstrings for marimo notebook cells (files prefixed with `marimo_*`) that use the pattern `@app.cell def __(`.</standard>
    </code_quality>

    <testing>
      <standard>Use pytest exclusively for all testing (no unittest module).</standard>
      <standard>Place all tests in `./tests/` directory.</standard>
      <standard>Include `__init__.py` files in all test directories.</standard>
      <standard>Add type annotations and docstrings to all tests.</standard>
      <standard>Use pytest markers to categorize tests (e.g., `@pytest.mark.unit`, `@pytest.mark.integration`).</standard>
      <standard>Mark cursor-generated code with `@pytest.mark.cursor`.</standard>
      <standard>Strive for 100% unit test code coverage.</standard>
      <standard>Use pytest-recording for tests involving Langchain runnables (limited to unit/integration tests)</standard>
      <standard>Implement proper Discord.py testing using discord.ext.test</standard>
      <standard>Use typer.testing.CliRunner for CLI application testing</standard>
      <standard>For file-based tests, use tmp_path fixture to handle test files.</standard>
      <standard>Avoid context managers for pytest mocks, use mocker.patch instead.</standard>
    </testing>

    <dependency_management>
      <standard>Use uv (https://docs.astral.sh/uv) for dependency management.</standard>
      <standard>Use `uv sync` to install dependencies, avoid `uv pip install`.</standard>
      <standard>Use Ruff for code style consistency.</standard>
      <standard>Document Ruff rules in pyproject.toml with stability indicators.</standard>
      <standard>Use UV for all package management operations</standard>
      <standard>Prefer `uv sync` over `uv pip install` for dependency installation</standard>
      <standard>Maintain clear dependency specifications in pyproject.toml</standard>
    </dependency_management>

    <langchain_standards>
      <standard>Mark tests involving Langchain runnables with @pytest.mark.vcr (except evaluation tests).</standard>
      <standard>Use proper VCR.py configuration for HTTP interaction recording.</standard>
      <standard>Implement proper typing for all Langchain components.</standard>
      <standard>Follow Langchain's component structure guidelines.</standard>
    </langchain_standards>

    <langchain_integration>
      <standard>Implement proper typing for all LangChain components</standard>
      <standard>Follow component structure guidelines from LangChain documentation</standard>
      <standard>Use VCR.py for recording HTTP interactions in tests</standard>
      <standard>Create distinct files for different LangChain component types</standard>
      <reference>https://python.langchain.com/v0.2/docs/concepts/#few-shot-prompting</reference>
    </langchain_integration>

    <design_patterns>
      <pattern>
        <name>Composition Over Inheritance</name>
        <description>Favor object composition over class inheritance to avoid subclass explosion and enhance flexibility</description>
      </pattern>
      <pattern>
        <name>Decorator Pattern</name>
        <description>Use for dynamically adjusting behavior of objects without modifying their structure</description>
      </pattern>
      <pattern>
        <name>Adapter Pattern</name>
        <description>Allow incompatible interfaces to work together, promoting flexibility and reusability</description>
      </pattern>
      <pattern>
        <name>Global Object Pattern</name>
        <description>Use for creating module-level objects that provide methods for actions</description>
      </pattern>
    </design_patterns>
  </python_standards>

  <configuration_standards>
    <ruff_rules>
      <standard>Document all Ruff rules in pyproject.toml with inline comments.</standard>
      <standard>Include stability indicators for each rule:
        - ‚úîÔ∏è (stable)
        - üß™ (unstable/preview)
        - ‚ö†Ô∏è (deprecated)
        - ‚ùå (removed)
        - üõ†Ô∏è (auto-fixable)
      </standard>
      <standard>Keep rule descriptions under 160 characters when possible.</standard>
      <standard>Reference Ruff version from .pre-commit-config.yaml.</standard>
      <example>
        <![CDATA[
        [tool.ruff.lint]
        select = [
            "D200", # fits-on-one-line: One-line docstring should fit on one line (stable)
            "E226", # missing-whitespace-around-arithmetic-operator: Missing whitespace around arithmetic operator (unstable)
        ]
        ]]>
      </example>
    </ruff_rules>

    <tool_configurations>
      <standard>Document configuration options for:
        - pylint (reference: pylint.pycqa.org)
        - pyright (reference: microsoft.github.io/pyright)
        - mypy (reference: mypy.readthedocs.io)
        - commitizen (reference: commitizen-tools.github.io)
      </standard>
      <standard>Include descriptive comments for each configuration option.</standard>
    </tool_configurations>

    <test_imports>
      <standard>Import necessary pytest types in TYPE_CHECKING block:
        - CaptureFixture
        - FixtureRequest
        - LogCaptureFixture
        - MonkeyPatch
        - MockerFixture
        - VCRRequest (when using pytest-recording)
      </standard>
    </test_imports>
  </configuration_standards>

  <testing_practices>
    <fixtures>
      <standard>Use pytest fixtures for reusable test components.</standard>
      <standard>Utilize tmp_path fixture for file-based tests.</standard>
      <example>
        <![CDATA[
        @pytest.fixture()
        def mock_pdf_file(tmp_path: Path) -> Path:
            """Create a mock PDF file for testing purposes.

            This fixture creates a temporary directory and copies a test PDF file into it.

            Args:
                tmp_path (Path): The temporary path provided by pytest.

            Returns:
                Path: Path to the mock PDF file.
            """
            test_pdf_path: Path = tmp_path / "test.pdf"
            shutil.copy("fixtures/test.pdf", test_pdf_path)
            return test_pdf_path
        ]]>
      </example>
    </fixtures>

    <test_organization>
      <standard>Mirror source code directory structure in tests directory.</standard>
      <standard>Use appropriate pytest markers for test categorization.</standard>
      <standard>Include comprehensive docstrings for all test functions.</standard>
      <example>
        <![CDATA[
        @pytest.mark.slow()
        @pytest.mark.services()
        @pytest.mark.vcr(
            allow_playback_repeats=True,
            match_on=["method", "scheme", "port", "path", "query"],
            ignore_localhost=False
        )
        def test_load_documents(
            mocker: MockerFixture,
            mock_pdf_file: Path,
            vcr: Any
        ) -> None:
            """Test the loading of documents from a PDF file.

            Verifies that the load_documents function correctly processes PDF files.

            Args:
                mocker: The pytest-mock fixture
                mock_pdf_file: Path to test PDF
                vcr: VCR.py fixture
            """
            # Test implementation
        ]]>
      </example>
    </test_organization>
  </testing_practices>

  <examples>
    <example>
      <![CDATA[
      Example folder structure:
prompt-library/
‚îÇ
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ creative/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ image-generation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fabrication/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ story-generation/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ quote-generation/
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ engineering/
‚îÇ       ‚îú code-generation/
‚îÇ       ‚îú‚îÄ‚îÄ code-review/
‚îÇ       ‚îú‚îÄ‚îÄ bug-finding/
‚îÇ       ‚îî‚îÄ‚îÄ style-enforcement/
‚îÇ
‚îú‚îÄ‚îÄ one-off-tasks/
‚îÇ   ‚îú‚îÄ‚îÄ image-generation/
‚îÇ   ‚îú‚îÄ‚îÄ lore-writing/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ helldivers2/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ johnhelldiver/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ prompt.xml
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ prompt_schema.xsd
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ Justfile
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ metadata.json
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ examples/
‚îÇ   ‚îÇ               ‚îú‚îÄ‚îÄ example1.md
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ example2.md
‚îÇ   ‚îú‚îÄ‚îÄ code-generation/
‚îÇ   ‚îî‚îÄ‚îÄ code-review/
‚îÇ
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ prompt_template.xml
‚îÇ   ‚îú‚îÄ‚îÄ readme_template.md
‚îÇ   ‚îî‚îÄ‚îÄ metadata_template.json
‚îÇ
‚îî‚îÄ‚îÄ README.md
      ]]>
    </example>
    <example>
      <![CDATA[
      Example README.md content:
      # Prompt Library

      This repository contains a structured collection of prompts for various AI tasks.

      ## Structure
      - `agents/`: Prompts for continuous use in agentic systems
      - `one-off-tasks/`: Prompts for single-use scenarios
      - `templates/`: Reusable prompt structures

      ## Usage
      [Include guidelines on how to use and contribute to the library]
      ]]>
    </example>
        <example>
      <![CDATA[
      Example prompt.xml for John Helldiver:
      <?xml version="1.0" encoding="UTF-8"?>
      <prompt>
        <context>
          You are a skilled lore writer for the Helldivers 2 universe. Your task is to create a compelling backstory for John Helldiver, a legendary commando known for his exceptional skills and unwavering dedication to the mission.
        </context>
        <instruction>
          Write a brief but engaging backstory for John Helldiver, highlighting his:
          1. Origin and early life
          2. Key missions and accomplishments
          3. Unique personality traits
          4. Signature weapons or equipment
          5. Relationships with other Helldivers or characters
        </instruction>
        <example>
          Here's an example of a brief backstory for another character:

          Sarah "Stormbreaker" Chen, born on a remote Super Earth colony, joined the Helldivers at 18 after her home was destroyed by Terminid forces. Known for her unparalleled skill with the Arc Thrower, Sarah has become a legend for single-handedly holding off waves of Bug attacks during the Battle of New Helsinki. Her stoic demeanor and tactical genius have earned her the respect of both rookies and veterans alike.
        </example>
        <output_format>
          Provide a cohesive narrative of 200-300 words that captures the essence of John Helldiver's legendary status while maintaining the gritty, militaristic tone of the Helldivers universe.
        </output_format>
      </prompt>
      ]]>
    </example>
    <example>
      <![CDATA[
      Example README.md for John Helldiver:
      # John Helldiver Backstory Prompt

      ## Purpose
      This prompt is designed to generate a compelling backstory for John Helldiver, a legendary commando in the Helldivers 2 universe. It aims to create a rich, engaging narrative that fits seamlessly into the game's lore.

      ## Usage
      1. Use this prompt with a large language model capable of creative writing and understanding context.
      2. Provide the prompt to the model without modification.
      3. The generated output should be a 200-300 word backstory that can be used as-is or as a foundation for further development.

      ## Expected Output
      A brief but detailed backstory covering John Helldiver's origin, key accomplishments, personality traits, equipment, and relationships within the Helldivers universe.

      ## Special Considerations
      - Ensure the tone matches the gritty, militaristic style of Helldivers 2.
      - The backstory should emphasize John's exceptional skills and dedication to his missions.
      - Feel free to iterate on the output, using it as a starting point for more detailed character development.
      ]]>
    </example>
        <example>
      <![CDATA[
      Example metadata.json for John Helldiver:
      {
        "promptName": "JohnHelldiverBackstory",
        "version": "1.0",
        "targetModel": "gpt4o",
        "author": "YourName",
        "creationDate": "2024-12-08",
        "lastTestedDate": "2024-12-08",
        "tags": ["Helldivers2", "lore", "character-backstory", "sci-fi"],
        "description": "Generates a backstory for John Helldiver, a legendary commando in the Helldivers 2 universe",
        "performanceMetrics": {
          "averageOutputQuality": 4.5,
          "successRate": 0.95
        },
        "promptStructure": "Four-level prompt (Context, Instruction, Example, Output Format)"
      }
      ]]>
    </example>
    <example>
      <![CDATA[
      Example examples/example1.md for John Helldiver:
      # Example Output 1: John Helldiver Backstory

      John "Hellfire" Helldiver was born in the underground bunkers of Super Earth during the height of the Bug War. Raised by veteran Helldivers, John's childhood was a brutal training regimen that forged him into a living weapon. At 16, he led his first mission against a Terminid hive, earning his call sign "Hellfire" after single-handedly destroying the hive with nothing but a flamethrower and sheer determination.

      Known for his uncanny ability to turn the tide of impossible battles, John has become a symbol of hope for humanity. His most famous exploit came during the Siege of New Atlantis, where he held off waves of Automaton forces for 72 hours straight, allowing thousands of civilians to evacuate. John's preferred loadout includes a customized Liberator assault rifle and the experimental P-7 "Punisher" sidearm, both gifts from Super Earth's top weapons engineers.

      Despite his legendary status, John remains a man of few words, letting his actions speak louder than any speech could. His unwavering loyalty to Super Earth and his fellow Helldivers is matched only by his hatred for the enemies of democracy. Rookies whisper that John Helldiver doesn't sleep; he just waits for the next drop.

      (Word count: 182)
      ]]>
    </example>
    <example>
      <![CDATA[
      Example prompt_schema.xsd:
      <?xml version="1.0" encoding="UTF-8"?>
      <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
        <xs:element name="prompt">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="context" type="xs:string"/>
              <xs:element name="instruction" type="xs:string"/>
              <xs:element name="example" type="xs:string"/>
              <xs:element name="output_format" type="xs:string"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:schema>
      ]]>
    </example>
    <example>
      <![CDATA[
      Example Justfile:
      lint:
        xmllint --schema prompt_schema.xsd prompt.xml --noout
      ]]>
    </example>
  </examples>

  <reasoning>
    <point>Hierarchical structure allows for easy navigation and scalability.</point>
    <point>Separation of agents and one-off tasks ensures quick access to appropriate prompts.</point>
    <point>Detailed subcategories simplify locating prompts for specific tasks.</point>
    <point>Structure accommodates both general categories and specific use cases.</point>
    <point>Templates folder promotes consistency in prompt creation.</point>
    <point>README file provides clear documentation for all users.</point>
  </reasoning>

  <prompt_engineering_standards>
    <xml_structure>
      <standard>Use clear, descriptive tag names that are self-explanatory (e.g., &lt;context&gt;, &lt;task&gt;, &lt;examples&gt;).</standard>
      <standard>Organize content hierarchically with proper nesting of tags.</standard>
      <standard>Maintain consistent tag usage throughout prompts.</standard>
      <standard>Use line breaks and indentation for readability.</standard>
    </xml_structure>

    <component_organization>
      <standard>Separate different components with distinct tags.</standard>
      <standard>Use &lt;context&gt; for background information.</standard>
      <standard>Use &lt;instructions&gt; for specific directives.</standard>
      <standard>Use &lt;examples&gt; for sample inputs and outputs.</standard>
      <standard>Use &lt;output_format&gt; to define response structure.</standard>
      <standard>Use &lt;reflection&gt; for AI thinking steps.</standard>
    </component_organization>

    <best_practices>
      <standard>Include only necessary information in each tag.</standard>
      <standard>Number or bullet point instructions for clarity.</standard>
      <standard>Use variables with descriptive names (e.g., &lt;variable_name&gt;{{value}}&lt;/variable_name&gt;).</standard>
      <standard>Combine XML tags with other prompt engineering techniques when appropriate.</standard>
      <standard>Include validation using XSD schemas for prompt structure.</standard>
    </best_practices>

    <reflection_patterns>
      <standard>Include explicit thinking steps in prompts using &lt;reflection&gt; tags.</standard>
      <standard>Break down complex tasks into clear steps.</standard>
      <standard>Use chain-of-thought prompting for complex reasoning.</standard>
      <example>
        <![CDATA[
        <prompt>
          <context>Analyzing a complex codebase for refactoring.</context>
          <reflection>
            1. First, I'll identify the main components and their relationships
            2. Then, I'll analyze each component for SOLID principles
            3. Finally, I'll propose specific refactoring steps
          </reflection>
          <output_format>
            Provide a structured analysis with:
            - Component relationships
            - SOLID violations
            - Refactoring proposals
          </output_format>
        </prompt>
        ]]>
      </example>
    </reflection_patterns>

    <variable_handling>
      <standard>Use descriptive variable names in XML tags.</standard>
      <standard>Include type hints and validation rules for variables.</standard>
      <standard>Document expected formats and constraints.</standard>
      <example>
        <![CDATA[
        <prompt>
          <variables>
            <code_snippet type="python" max_length="500">{{code_to_review}}</code_snippet>
            <style_guide type="url">{{style_guide_link}}</style_guide>
            <severity_level type="enum" values="high,medium,low">{{severity}}</severity_level>
          </variables>
          <task>Review the code according to the style guide at the specified severity level.</task>
        </prompt>
        ]]>
      </example>
    </variable_handling>
  </prompt_engineering_standards>

  <marimo_standards>
    <cell_definition>
      <standard>All cells must be decorated with @app.cell.</standard>
      <standard>Always use explicit tuple returns, even for single values.</standard>
      <standard>No function definitions allowed in marimo notebook files (prefix: marimo_*).</standard>
      <standard>All functions must be imported from prompt_library_module.py.</standard>
      <standard>No error handling in notebook cells - handle errors in imported functions.</standard>
      <standard>Cell parameters should only include variables actually used in the cell.</standard>
      <standard>Skip type annotations and docstrings for marimo notebook cells.</standard>
      <example>
        <![CDATA[
        # ‚úÖ Correct Pattern
        from prompt_library_module import process_data

        @app.cell
        def __(previous_output):
            result = process_data(previous_output)
            return (result,)

        # ‚ùå Common Errors
        @app.cell
        def __(unused_param):  # Don't include unused parameters
            def local_func():  # Don't define functions in cells
                pass
            try:  # Don't do error handling in cells
                result = process()
            except Exception:
                pass
            return result  # Missing tuple wrapping
        ]]>
      </example>
    </cell_definition>

    <state_management>
      <standard>All cell dependencies must be explicitly declared as parameters.</standard>
      <standard>Avoid mutating shared state between cells.</standard>
      <standard>Use proper typing for all state variables.</standard>
      <example>
        <![CDATA[
        # ‚úÖ Correct Pattern
        from prompt_library_module import transform_data

        @app.cell
        def __(data, config):
            transformed = transform_data(data, config)
            return (transformed,)

        # ‚ùå Common Errors
        @app.cell
        def __(data, unused_param):  # Remove unused param
            result = []  # Don't create mutable state
            for item in data:
                result.append(item)  # Use transform_data from module instead
            return (result,)
        ]]>
      </example>
    </state_management>

    <ui_components>
      <standard>UI components should be created and modified through the reactive system.</standard>
      <standard>Use proper typing for all UI components.</standard>
      <standard>Include descriptive labels and help text.</standard>
      <example>
        <![CDATA[
        # ‚úÖ Correct Pattern
        @app.cell
        def __() -> tuple[mo.ui.Select, mo.ui.Slider]:
            """Create UI components for model selection and temperature control.

            Returns:
                tuple[mo.ui.Select, mo.ui.Slider]: Model selector and temperature slider
            """
            model_select = mo.ui.Select(
                options=["gpt-4", "gpt-3.5-turbo"],
                value="gpt-3.5-turbo",
                label="Select Model",
                help="Choose the model to use for generation"
            )

            temp_slider = mo.ui.Slider(
                value=0.7,
                min=0.0,
                max=1.0,
                step=0.1,
                label="Temperature",
                help="Controls randomness in generation"
            )

            return (model_select, temp_slider)

        # ‚ùå Common Errors
        @app.cell
        def __(slider):
            slider.value = 0.5  # Direct mutation - avoid this
            return ()
        ]]>
      </example>
    </ui_components>

    <error_handling>
      <standard>Use proper error boundaries and guards in each cell.</standard>
      <standard>Provide descriptive error messages with context.</standard>
      <standard>Use mo.stop() for validation guards.</standard>
      <example>
        <![CDATA[
        # ‚úÖ Correct Pattern
        @app.cell
        def __(form: mo.ui.Form, mo: Any) -> tuple[str]:
            """Process form data with proper error handling.

            Args:
                form: The form UI component
                mo: The marimo module

            Returns:
                tuple[str]: Processing result or error message
            """
            # Guard clause
            mo.stop(not form.value, "Please fill out the form")

            try:
                result = process_form_data(form.value)
                return (result,)
            except ValidationError as e:
                mo.md(f"""
                ‚ùå **Validation Error**:
                ```
                {str(e)}
                ```
                Please check your input and try again.
                """).style({
                    "color": "red",
                    "padding": "10px",
                    "border-radius": "5px",
                    "background": "#ffebee"
                })
                return ("",)
            except Exception as e:
                mo.md(f"""
                ‚ùå **Unexpected Error**:
                ```
                {str(e)}
                ```
                Please contact support if this persists.
                """).style({
                    "color": "red",
                    "padding": "10px",
                    "border-radius": "5px",
                    "background": "#ffebee"
                })
                return ("",)

        # ‚ùå Common Errors
        @app.cell
        def __():
            result = process_data()  # Missing try/except
            return (result,)
        ]]>
      </example>
    </error_handling>

    <cell_dependencies>
      <standard>All cell dependencies must be explicitly declared.</standard>
      <standard>Avoid circular dependencies between cells.</standard>
      <standard>Use proper ordering of cells based on dependencies.</standard>
      <example>
        <![CDATA[
        # ‚úÖ Correct Pattern
        @app.cell
        def __(data: pd.DataFrame) -> tuple[dict[str, Any]]:
            """Process input data and return statistics.

            Args:
                data: Input DataFrame to analyze

            Returns:
                tuple[dict[str, Any]]: Dictionary of statistics
            """
            stats = calculate_statistics(data)
            return (stats,)

        @app.cell
        def __(stats: dict[str, Any]) -> tuple[mo.md]:
            """Create markdown display of statistics.

            Args:
                stats: Dictionary of statistics to display

            Returns:
                tuple[mo.md]: Formatted markdown output
            """
            return (mo.md(f"Statistics:\n{stats}"),)

        # ‚ùå Common Errors
        # Circular dependency
        @app.cell
        def __(cell2_output):
            return (cell2_output * 2,)

        @app.cell
        def __(cell1_output):
            return (cell1_output + 1,)
        ]]>
      </example>
    </cell_dependencies>

    <ui_styling>
      <standard>Use consistent styling objects for UI components.</standard>
      <standard>Follow Material Design principles for component styling.</standard>
      <standard>Maintain responsive design patterns.</standard>
      <example>
        <![CDATA[
        @app.cell
        def __() -> tuple[dict[str, Any]]:
            """Define reusable UI styles.

            Returns:
                tuple[dict[str, Any]]: Dictionary of style configurations
            """
            styles = {
                "container": {
                    "max-width": "800px",
                    "margin": "0 auto",
                    "padding": "20px",
                },
                "card": {
                    "background": "#ffffff",
                    "border-radius": "8px",
                    "box-shadow": "0 2px 4px rgba(0,0,0,0.1)",
                    "padding": "16px",
                    "margin-bottom": "16px",
                },
                "error": {
                    "color": "red",
                    "padding": "10px",
                    "border-radius": "5px",
                    "background": "#ffebee",
                },
                "success": {
                    "color": "green",
                    "padding": "10px",
                    "border-radius": "5px",
                    "background": "#e8f5e9",
                }
            }
            return (styles,)

        @app.cell
        def __(styles: dict[str, Any]) -> tuple[mo.md]:
            """Create styled UI components.

            Args:
                styles: Dictionary of style configurations

            Returns:
                tuple[mo.md]: Styled markdown component
            """
            return (
                mo.md("# Dashboard").style(styles["container"]),
            )
        ]]>
      </example>
    </ui_styling>

    <python_differences>
      <standard>Understand key differences from regular Python code.</standard>
      <standard>Follow Marimo-specific patterns for state and reactivity.</standard>
      <example>
        <![CDATA[
        # Regular Python vs Marimo Patterns

        # ‚ùå Regular Python - Global State
        global_counter = 0
        def increment():
            global global_counter
            global_counter += 1

        # ‚úÖ Marimo - Reactive State
        @app.cell
        def __() -> tuple[int]:
            """Initialize counter state.

            Returns:
                tuple[int]: Initial counter value
            """
            return (0,)

        @app.cell
        def __(counter: int) -> tuple[int]:
            """Increment counter reactively.

            Args:
                counter: Current counter value

            Returns:
                tuple[int]: Incremented counter value
            """
            return (counter + 1,)

        # ‚ùå Regular Python - Direct DOM Updates
        def update_ui():
            document.getElementById("result").innerHTML = "Updated"

        # ‚úÖ Marimo - Reactive UI Updates
        @app.cell
        def __(data: Any) -> tuple[mo.md]:
            """Update UI reactively based on data changes.

            Args:
                data: Data to display

            Returns:
                tuple[mo.md]: Updated UI component
            """
            return (mo.md(f"Result: {data}"),)
        ]]>
      </example>
    </python_differences>

    <reactive_patterns>
      <standard>Use reactive programming patterns for UI and state updates.</standard>
      <standard>Maintain unidirectional data flow.</standard>
      <standard>Handle side effects properly in reactive contexts.</standard>
      <example>
        <![CDATA[
        # ‚úÖ Correct Reactive Pattern
        @app.cell
        def __() -> tuple[mo.ui.Text, mo.ui.Button]:
            """Create input and action components.

            Returns:
                tuple[mo.ui.Text, mo.ui.Button]: Text input and submit button
            """
            text_input = mo.ui.text(placeholder="Enter text")
            submit_btn = mo.ui.button("Submit")
            return (text_input, submit_btn)

        @app.cell
        def __(
            text_input: mo.ui.Text,
            submit_btn: mo.ui.Button
        ) -> tuple[mo.md]:
            """Handle reactive updates based on input changes.

            Args:
                text_input: Text input component
                submit_btn: Submit button component

            Returns:
                tuple[mo.md]: Updated display component
            """
            if not submit_btn.clicked:
                return (mo.md("Waiting for submission..."),)

            if not text_input.value:
                return (mo.md("Please enter some text."),)

            return (mo.md(f"Submitted: {text_input.value}"),)

        # ‚ùå Common Anti-patterns
        @app.cell
        def __(text_input: mo.ui.Text):
            # Direct mutation of state
            global_state["text"] = text_input.value
            # Missing tuple return
            return text_input.value
        ]]>
      </example>
    </reactive_patterns>
  </marimo_standards>
</cursorrules>
